{
    "name": "360 安全规则集合",
    "version": "1.3.2",
    "encoding": "utf-8",
    "language": "C,C++",
    "url": "https://github.com/Qihoo360/safe-rules/blob/main/c-cpp-rules.md",

    "//": [
        "下面以 ID_ 开头的键为规则标识符，对应的值为规则内容。",

        "规则内容包括：",
        "   checkPoint：规则的定义",
        "   comment：对规则的简要说明",
        "   standard：相关的 ISO/IEC 标准条款",
        "   reference：参考条目",
        "   tag：规则的类别",
        "   level：违反规则的后果严重程度",
        "   related：有相关性的其他规则",
        "   config：相关配置项的名称及含义",

        "level 分为：",
        "   error：直接导致错误或形成安全漏洞",
        "   warning：可导致错误或形成安全隐患",
        "   suspicious：可疑的代码，需进一步排查",
        "   suggestion：代码质量降低，应依照建议改进"
    ],

    "ID_sizeof_oddExpression": {
        "checkPoint": "sizeof 不应作用于逻辑表达式",
        "level": "warning",
        "comment": "sizeof 作用于 <、>、<=、>=、==、!=、&&、|| 等逻辑表达式为常见笔误，逻辑运算符往往应该移出 sizeof 表达式。",
        "tag": "expression"
        },
    "ID_sizeof_pointerDivision": {
        "checkPoint": "被除数不应是作用于指针的 sizeof 表达式",
        "level": "warning",
        "comment": "形如 sizeof(p) / n 的表达式往往意在获取数组元素的个数，如果 p 是指针，sizeof(p) 是指针大小而不是数组大小，结果很可能是错误的。",
        "tag": "expression",
        "related": "ID_sizeof_pointer",
        "reference": "CWE-467"
        },
    "ID_sizeof_void": {
        "checkPoint": "sizeof 不可作用于 void",
        "level": "error",
        "comment": "void 表示不存在的类型，也是不完整的类型，sizeof 作用于 void 是没意义的，属于语言运用错误，也可能是 sizeof(void*) 的笔误。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.2.5(19),ISO/IEC 9899:1999 6.3.2.2(1),ISO/IEC 9899:2011 6.2.5(19),ISO/IEC 9899:2011 6.3.2.2(1)"
        },
    "ID_differentEnumComparison": {
        "checkPoint": "不应比较非同类枚举值",
        "level": "warning",
        "comment": "比较非同类枚举值相当于比较不同类别的事物，没有逻辑意义，往往是设计缺陷或逻辑错误。",
        "tag": "expression"
        },
    "ID_ptrIntCast": {
        "checkPoint": "指针与整数不应相互转换",
        "level": "warning",
        "comment": "指针与整数相互转换容易造成地址不完整、寻址错误、降低可移植性等多种问题。",
        "config": [
            "allowPointerToSizeType: 是否放过指针与 size_t 的转换"
            ],
        "tag": "cast",
        "standard": "ISO/IEC 9899:1999 6.3.2.3(5)-implementation,ISO/IEC 9899:1999 7.18.1.4(1),ISO/IEC 9899:2011 6.3.2.3(5)-implementation,ISO/IEC 9899:2011 7.20.1.4(1),ISO/IEC 14882:2003 5.2.10(4 5)-implementation,ISO/IEC 14882:2011 3.7.4.3(1),ISO/IEC 14882:2011 5.2.10(4 5)-implementation",
        "related": "ID_fixedAddrToPointer",
        "reference": "MISRA C 2004 11.3,MISRA C 2012 11.4,MISRA C++ 2008 5-2-9,SEI CERT INT36-C"
        },
    "ID_zeroAsPtrValue": {
        "checkPoint": "不应使用常量 0 表示空指针",
        "level": "suggestion",
        "comment": "在 C 代码中应使用 NULL 表示空指针，在 C++ 代码中应使用 nullptr 表示空指针。",
        "tag": "pointer",
        "related": "ID_oddPtrBoolAssignment,ID_oddPtrCharAssignment,ID_oddPtrBoolComparison,ID_oddPtrCharComparison",
        "standard": "ISO/IEC 9899:1999 6.3.2.3(3),ISO/IEC 9899:2011 6.3.2.3(3),ISO/IEC 14882:2003 4.10(1),ISO/IEC 14882:2011 4.10(1)",
        "reference": "C++ Core Guidelines ES.47,MISRA C 2012 11.9,MISRA C++ 2008 4-10-2"
        },
    "ID_charWCharCast": {
        "checkPoint": "不同的字符串类型之间不可直接转换",
        "level": "warning",
        "comment": "char* 和 wchar_t* 直接转换并不进行字符集编码转换，往往意味着语言运用错误，char*、wchar_t*、char16_t* 和 char32_t* 之间均不可直接转换。",
        "tag": "cast",
        "related": "ID_castNoInheritance,ID_plainBinaryChar",
        "reference": "CWE-704,SEI CERT STR38-C"
        },
    "ID_repeatedUnaryOperators": {
        "checkPoint": "不应重复使用一元运算符",
        "level": "warning",
        "comment": "重复的一元运算符没有意义，为常见笔误。",
        "tag": "expression"
        },
    "ID_minusOnUnsigned": {
        "checkPoint": "负号不应作用于无符号整数",
        "level": "warning",
        "comment": "负号作用于 unsigned int、unsigned long 或 unsigned long long 等无符号整型表达式的结果仍为无符号整数，易产生意料之外的错误。",
        "tag": "expression",
        "config": [
            "allowSmallUnsignedTypes: 是否允许负号作用于 unsigned char、unsigned short 等无符号整型表达式"
            ],
        "standard": "ISO/IEC 9899:1999 6.5.3.3(3),ISO/IEC 9899:2011 6.5.3.3(3)",
        "reference": "MISRA C 2004 12.9,MISRA C 2012 10.1,MISRA C++ 2008 5-3-2"
        },
    "ID_bitwiseOperOnSigned": {
        "checkPoint": "位运算符不应作用于有符号整数",
        "level": "warning",
        "comment": "符号位在位运算方面没有逻辑意义，对负数进行位运算往往意味着逻辑错误。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.5.7(3)-undefined,ISO/IEC 9899:2011 6.5.7(3)-undefined,ISO/IEC 14882:2003 5.8(2),ISO/IEC 14882:2003 5.8(3)-implementation,ISO/IEC 14882:2011 5.8(2)-undefined,ISO/IEC 14882:2011 5.8(3)-implementation",
        "reference": "CWE-682,C++ Core Guidelines ES.101,MISRA C 2004 12.7,MISRA C 2012 10.1,MISRA C++ 2008 5-0-21"
        },
    "ID_simplifiableTernary": {
        "checkPoint": "化简可转换为逻辑表达式的三元表达式",
        "level": "suggestion",
        "comment": "当三元表达式的分枝是常量 true 或 false 时应化简为逻辑表达式。",
        "tag": "expression"
        },
    "ID_stickyAssignmentOperator": {
        "checkPoint": "注意赋值运算符与一元运算符的空格方式",
        "level": "warning",
        "comment": "如果 = 与 +、-、*、!、&、~ 等一元运算符之间没有空格，而一元运算符与其子表达式之间有空格，是一种非常怪异的格式，也可能是 +=、-=、*=、&= 等复合赋值运算符的笔误。",
        "tag": "expression",
        "reference": "CWE-480"
        },
    "ID_redundantParentheses": {
        "checkPoint": "避免多余的括号",
        "level": "suggestion",
        "comment": "重复的或与优先级无关的括号使代码显得繁琐，应去掉。",
        "tag": "style",
        "reference": "MISRA C++ 2008 5-0-2"
        },
    "ID_throwNULL": {
        "checkPoint": "不应抛出 NULL",
        "level": "warning",
        "comment": "虽然 NULL 表示空指针，但在相当一部分实现中 throw NULL 相当于 throw 0，无法区分指针与整数。",
        "tag": "exception",
        "related": "ID_deprecatedNULL,ID_throwNonExceptionType,ID_throwPointer",
        "standard": "ISO/IEC 14882:2003 C.2.2.3(1)-implementation,ISO/IEC 14882:2011 C.3.2.4(1)-implementation,ISO/IEC 14882:2017 C.5.2.7(1)-implementation",
        "reference": "CWE-351,MISRA C++ 2008 15-1-2"
        },
    "ID_throwNullptr": {
        "checkPoint": "不应抛出 nullptr",
        "level": "warning",
        "comment": "nullptr 可被所有接受指针的 catch 子句捕获，使异常处理失去针对性。",
        "tag": "exception",
        "related": "ID_throwPointer",
        "reference": "MISRA C++ 2008 15-0-2"
        },
    "ID_throwNonExceptionType": {
        "checkPoint": "不应抛出非异常类型的对象",
        "level": "warning",
        "comment": "不应将整数、字符串等非异常类的对象当作异常抛出，否则意味着异常相关的设计是不健全的。",
        "config": [
            "mustInheritStdException: 是否要求异常类必须派生自 std::exception"
            ],
        "tag": "exception",
        "related": "ID_catch_nonExceptionType",
        "reference": "C++ Core Guidelines E.14,C++ Core Guidelines E.3"
        },
    "ID_throwGenericException": {
        "checkPoint": "不应抛出过于宽泛的异常",
        "level": "warning",
        "comment": "抛出过于宽泛的异常，如 std::exception、std::logic_error、std::runtime_error 等类型的异常，会使异常处理失去针对性，而且处理这种异常时很可能会将本不应处理的异常一并捕获。",
        "tag": "exception",
        "related": "ID_catch_generic",
        "reference": "CWE-397"
        },
    "ID_rethrowOutOfCatch": {
        "checkPoint": "不应在 catch 子句外使用空 throw 表达式（throw;）",
        "level": "warning",
        "comment": "空 throw 表达式用于重新抛出当前捕获的异常，用在 catch 子句外是危险的，增大了流程控制的复杂性。",
        "tag": "exception",
        "standard": "ISO/IEC 14882:2003 15.1(6 8),ISO/IEC 14882:2003 15.3(9)-implementation,ISO/IEC 14882:2011 15.1(8 9),ISO/IEC 14882:2011 15.3(9)-implementation",
        "reference": "MISRA C++ 2008 15-1-3"
        },
    "ID_improperRethrow": {
        "checkPoint": "重新抛出异常时应使用空 throw 表达式（throw;）",
        "level": "warning",
        "comment": "重新抛出异常时应使用空 throw 表达式，避免异常对象的精度损失和不必要的复制开销。",
        "tag": "exception",
        "standard": "ISO/IEC 14882:2003 15.1(6),ISO/IEC 14882:2011 15.1(8)"
        },
    "ID_forbidException": {
        "checkPoint": "禁用 C++ 异常",
        "level": "warning",
        "comment": "禁用 C++ 异常。",
        "tag": "exception",
        "related": "ID_exceptionUnsafe",
        "reference": "C++ Core Guidelines E.6,Google C++ Style Guide.Other C++ Features.Exceptions"
        },
    "ID_invalidExternSpecifier": {
        "checkPoint": "extern 关键字不应作用于类成员的声明或定义",
        "level": "warning",
        "comment": "extern 关键字作用于类成员的声明或定义是没有意义的，属于语言运用错误。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2003 9.2(6),ISO/IEC 14882:2011 9.2(6),ISO/IEC 14882:2017 12.2(9)"
        },
    "ID_invalidParamArraySize": {
        "checkPoint": "不应将数组作为函数的形式参数",
        "level": "warning",
        "comment": "数组作为形式参数时，其大小声明起不到实际的限制作用。",
        "tag": "declaration",
        "standard": "ISO/IEC 9899:1999 6.7.5.3(7),ISO/IEC 9899:2011 6.7.6.3(7)",
        "reference": "C++ Core Guidelines I.13,C++ Core Guidelines R.14,MISRA C++ 2008 5-2-12"
        },
    "ID_illMemberCall": {
        "checkPoint": "基类对象构造完毕之前不可调用成员函数",
        "level": "warning",
        "comment": "基类对象未构造完毕时调用成员函数会导致标准未定义的行为。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2003 12.6.2(8)-undefined,ISO/IEC 14882:2011 12.6.2(13)-undefined"
        },
    "ID_incompleteVaMacros": {
        "checkPoint": "va_start 或 va_copy 应配合 va_end 使用",
        "level": "warning",
        "comment": "可变参数列表相关的 va_start 或 va_copy 和 va_end 应在同一函数中使用，否则会导致标准未定义的错误。",
        "tag": "precompile",
        "related": "ID_forbidVariadicFunction",
        "standard": "ISO/IEC 9899:1999 7.15.1.3(2)-undefined,ISO/IEC 9899:2011 7.16.1.3(2)-undefined"
        },
    "ID_functionSpecialization": {
        "checkPoint": "函数模板不应被特化",
        "level": "warning",
        "comment": "特化的函数模板不参与重载函数的选取，易导致意类之外的错误。",
        "tag": "function",
        "reference": "C++ Core Guidelines T.144,MISRA C++ 2008 14-8-1"
        },
    "ID_tooManyLines": {
        "checkPoint": "函数的行数应在规定范围之内",
        "level": "warning",
        "comment": "函数体过大违反模块化编程理念，使人难以阅读，更不便于维护，应适当重构。",
        "config": [
            "maxLineCount: 函数行数上限，超过则报出"
            ],
        "tag": "function",
        "reference": "C++ Core Guidelines F.2,C++ Core Guidelines F.3"
        },
    "ID_unsuitableCapture": {
        "checkPoint": "合理设置 lambda 表达式的捕获方式",
        "level": "warning",
        "comment": "如果 lambda 表达式只在函数内部使用，可采用捕获引用的方式；如果 lambda 表达式可以超出函数作用域，应采用捕获值的方式。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2011 5.1.2,ISO/IEC 14882:2017 8.1.5.2",
        "related": "ID_localAddressFlowOut",
        "reference": "C++ Core Guidelines F.52,C++ Core Guidelines F.53,C++ Core Guidelines F.54"
        },
    "ID_tooManyLambdaLines": {
        "checkPoint": "lambda 表达式的行数应在规定范围之内",
        "level": "warning",
        "comment": "复杂的 lambda 表达式与调用者的代码混在一起是难以阅读的，引入 lambda 表达式的目的应该是“化简”，否则应使用普通函数。",
        "config": [
            "maxLambdaLineCount: lambda 表达式行数上限，超过则报出"
            ],
        "tag": "function"
        },
    "ID_tooManyLabels": {
        "checkPoint": "函数的标签数量应在规定范围之内",
        "level": "warning",
        "comment": "标签过多意味着函数内部的跳转逻辑过于复杂，违反结构化设计理念，应适当重构。",
        "config": [
            "maxLabelCount: 标签数量上限，超过则报出"
            ],
        "tag": "function"
        },
    "ID_memoryLeak": {
        "checkPoint": "不可失去对已分配内存的控制",
        "level": "warning",
        "comment": "动态分配的内存地址不可被遗失，否则相关内存无法被访问也无法被回收，这种问题称为“内存泄漏（memory leak）”，会导致可用内存被耗尽，使程序无法正常运行。",
        "tag": "resource",
        "related": "ID_resourceLeak,ID_ownerlessResource,ID_throwInConstructor,ID_memberDeallocation,ID_multiAllocation",
        "standard": "ISO/IEC 9899:1999 7.20.3(1),ISO/IEC 9899:2011 7.22.3(1),ISO/IEC 14882:2003 3.7.3.1(2),ISO/IEC 14882:2003 3.7.4.1(2)",
        "reference": "CWE-401,C++ Core Guidelines P.8,C++ Core Guidelines E.13"
    },
    "ID_resourceLeak": {
        "checkPoint": "不可失去对已分配资源的控制",
        "level": "warning",
        "comment": "对于动态分配的资源，其地址、句柄或描述符等标志性信息不可被遗失，否则资源无法被访问也无法被回收，这种问题称为“资源泄漏”，会导致资源耗尽或死锁等问题，使程序无法正常运行。",
        "tag": "resource",
        "related": "ID_memoryLeak,ID_asynchronousTermination",
        "reference": "CWE-772,C++ Core Guidelines P.8"
    },
    "ID_insufficientDelete": {
        "checkPoint": "用 delete 释放数组不可漏写中括号",
        "level": "error",
        "comment": "用 new 分配的数组应该用 delete[] 释放，不可漏写中括号，否则导致标准未定义的行为。",
        "tag": "resource",
        "related": "ID_excessiveDelete",
        "standard": "ISO/IEC 14882:2003 5.3.5(2)-undefined,ISO/IEC 14882:2011 5.3.5(2)-undefined,ISO/IEC 14882:2017 8.3.5(2)-undefined",
        "reference": "C++ Core Guidelines ES.61"
        },
    "ID_excessiveDelete": {
        "checkPoint": "用 delete 释放对象不可多写中括号",
        "level": "error",
        "comment": "用 new 分配的对象应该用 delete 释放，不可用 delete[] 释放，否则导致标准未定义的行为。",
        "tag": "resource",
        "related": "ID_insufficientDelete",
        "standard": "ISO/IEC 14882:2003 5.3.5(2)-undefined,ISO/IEC 14882:2011 5.3.5(2)-undefined,ISO/IEC 14882:2017 8.3.5(2)-undefined",
        "reference": "C++ Core Guidelines ES.61"
        },
    "ID_incompatibleDealloc": {
        "checkPoint": "资源的分配与回收方法应配套使用",
        "level": "error",
        "comment": "使用了某种分配方法，就应使用与其配套的回收方法，否则会引发严重错误。",
        "tag": "resource",
        "standard": "ISO/IEC 9899:1999 7.20.3.2(2)-undefined,ISO/IEC 9899:2011 7.22.3.3(2)-undefined,ISO/IEC 14882:2003 3.7.3.2(3),ISO/IEC 14882:2011 3.7.4.2(3)-undefined",
        "related": "ID_incompleteNewDeletePair",
        "reference": "SEI CERT MEM51-CPP"
        },
    "ID_illAccess": {
        "checkPoint": "不可访问未初始化或已释放的资源",
        "level": "error",
        "comment": "访问未初始化或已释放的资源属于逻辑错误，会导致标准未定义的行为。",
        "tag": "resource",
        "standard": "ISO/IEC 9899:1999 7.19.3(4),ISO/IEC 9899:2011 7.21.3(4)",
        "related": "ID_wildPtrDeref,ID_danglingDeref,ID_localInitialization",
        "reference": "CWE-672,CWE-908,SEI CERT FIO46-C,SEI CERT EXP53-CPP "
        },
    "ID_illDealloc": {
        "checkPoint": "非动态申请的资源不可被释放",
        "level": "error",
        "comment": "释放非动态申请的资源会导致标准未定义的行为。",
        "tag": "resource",
        "standard": "ISO/IEC 9899:1999 7.20.3.2(2)-undefined,ISO/IEC 9899:2011 7.22.3.3(2)-undefined,ISO/IEC 14882:2003 5.3.5(2)-undefined,ISO/IEC 14882:2011 5.3.5(2)-undefined",
        "reference": "MISRA C 2012 22.2"
        },
    "ID_doubleFree": {
        "checkPoint": "资源不可被重复释放",
        "level": "error",
        "comment": "重复释放资源属于逻辑错误，导致标准未定义的行为。",
        "tag": "resource",
        "standard": "ISO/IEC 9899:1999 7.20.3.2(2)-undefined,ISO/IEC 9899:2011 7.22.3.3(2)-undefined,ISO/IEC 14882:2003 3.7.3.2(4)-undefined,ISO/IEC 14882:2011 3.7.4.2(4)-undefined",
        "reference": "CWE-415"
        },
    "ID_invalidNullCheck": {
        "checkPoint": "避免无效的空指针检查",
        "level": "warning",
        "comment": "当指针的值一定不为空时，再对其进行检查是没有意义的，往往意味着逻辑错误。",
        "tag": "pointer",
        "related": "ID_repeatedNullCheck",
        "standard": "ISO/IEC 14882:2003 18.4,ISO/IEC 14882:2011 18.6"
        },
    "ID_repeatedNullCheck": {
        "checkPoint": "不应重复检查指针是否为空",
        "level": "warning",
        "comment": "重复的空指针检查是不必要的，使代码显得繁琐，且干扰编译器优化。",
        "tag": "pointer",
        "related": "ID_invalidNullCheck"
        },
    "ID_copiedStream": {
        "checkPoint": "流式资源对象不应被复制",
        "level": "warning",
        "comment": "FILE 等流式对象不应被复制，如果存在多个副本会造成数据不一致的问题。",
        "tag": "resource",
        "standard": "ISO/IEC 9899:1999 7.19.3(6),ISO/IEC 9899:2011 7.21.3(6)",
        "reference": "MISRA C 2012 22.5"
        },
    "ID_arrayIndexOverflow": {
        "checkPoint": "数组下标不可越界",
        "level": "error",
        "comment": "数组下标超过数组大小范围会导致标准未定义的行为。",
        "tag": "buffer",
        "related": "ID_bufferOverflow",
        "standard": "ISO/IEC 9899:1999 6.5.6(8)-undefined,ISO/IEC 9899:2011 6.5.6(8)-undefined,ISO/IEC 14882:2003 5.7(5)-undefined,ISO/IEC 14882:2011 5.7(5)-undefined",
        "reference": "C++ Core Guidelines ES.103,SEI CERT ARR30-C"
        },
    "ID_oddSubscripting": {
        "checkPoint": "数组下标应为整型表达式",
        "level": "warning",
        "comment": "C/C++ 语言规定，数组下标可以在中括号的右侧也可以在左侧，然而这只是一种理论上的设计，在实际代码中应采用约定俗成的方式，即数组的名称在中括号的左侧，下标在中括号的右侧。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.5.2.1(2),ISO/IEC 9899:2011 6.5.2.1(2),ISO/IEC 14882:2003 8.3.4(6),ISO/IEC 14882:2011 8.3.4(6)"
        },
    "ID_plainSensitiveInfo": {
        "checkPoint": "敏感数据不可写入代码",
        "level": "warning",
        "comment": "代码中的敏感数据极易泄露，产品以及相关运维、测试工具的代码均不可记录任何敏感数据。",
        "tag": "security",
        "related": "ID_secretLeak",
        "reference": "CWE-259,CWE-798,SEI CERT MSC41-C"
        },
    "ID_throwPointer": {
        "checkPoint": "不应抛出指针",
        "level": "suggestion",
        "comment": "抛出指针会增加不必要的内存管理成本，也容易造成意料之外的错误。",
        "tag": "exception",
        "reference": "MISRA C++ 2008 15-0-2"
        },
    "ID_if_tooManyElseIf": {
        "checkPoint": "if...else-if 分枝数量应在规定范围之内",
        "level": "warning",
        "comment": "if...else-if 分枝过多不利于阅读和维护，而且执行时需逐一判断各分枝的条件，效率较低，建议改为遵循某种算法的索引结构。",
        "config": [
            "maxElseIfCount: 分枝数量上限，超过则报出"
            ],
        "tag": "control"
        },
    "ID_for_floatCounter": {
        "checkPoint": "for 循环变量不应为浮点型",
        "level": "warning",
        "comment": "用于控制循环次数的变量称为“循环变量”，这种变量不应采用浮点类型，否则循环的次数难以控制。",
        "tag": "control",
        "related": "ID_illFloatComparison",
        "reference": "MISRA C 2004 13.4,MISRA C 2012 14.1,MISRA C++ 2008 6-5-1"
        },
    "ID_for_counterChangedInBody": {
        "checkPoint": "for 循环变量不应在循环体内被改变",
        "level": "warning",
        "comment": "用于控制循环次数的变量称为“循环变量”，为了使代码具有清晰的静态结构，循环变量只应在 for 语句的第 3 个表达式中被改变。",
        "tag": "control",
        "reference": "C++ Core Guidelines ES.86,MISRA C 2004 13.6,MISRA C++ 2008 6-5-3"
        },
    "ID_for_counterNested": {
        "checkPoint": "嵌套的 for 语句不应使用相同的循环变量",
        "level": "warning",
        "comment": "同一个循环变量在内外层 for 循环中均被修改，使循环次数难以控制，是过于复杂的循环逻辑，也可能是某种错误。",
        "tag": "control",
        "related": "ID_for_counterChangedInBody"
        },
    "ID_for_emptyBlock": {
        "checkPoint": "for 循环体不应为空",
        "level": "warning",
        "comment": "空的 for 循环结构不清晰，可读性较差。",
        "tag": "control",
        "reference": "C++ Core Guidelines ES.85"
        },
    "ID_switch_caseOutOfRange": {
        "checkPoint": "case 标签的值不可超出 switch 条件的范围",
        "level": "warning",
        "comment": "如果 case 标签的值超出了 switch 条件的范围，会导致相应分枝永远不会被执行。",
        "tag": "control",
        "related": "ID_illComparison",
        "reference": "CWE-561"
        },
    "ID_switch_uselessFallThrough": {
        "checkPoint": "不应存在紧邻 default 标签的空 case 标签",
        "level": "warning",
        "comment": "紧邻 default 标签的空 case 标签是没有意义的，应当去除。",
        "tag": "control"
        },
    "ID_switch_onlyDefault": {
        "checkPoint": "switch 语句不应只包含 default 标签",
        "level": "warning",
        "comment": "只有 default 标签的 switch 语句是没有意义的，起不到分枝选择的作用，往往是残留代码或功能未实现。",
        "tag": "control",
        "reference": "MISRA C 2012 16.6,MISRA C++ 2008 6-4-8"
        },
    "ID_switch_onlyOneCase": {
        "checkPoint": "switch 语句不应只包含一个 case 标签",
        "level": "warning",
        "comment": "只有一个 case 标签的 switch 语句与 if 语句语义相同，但形式上更为复杂，应改为 if 语句。",
        "tag": "control",
        "reference": "MISRA C 2012 16.6"
        },
    "ID_switch_tooManyCases": {
        "checkPoint": "switch 语句分枝数量应在规定范围之内",
        "level": "warning",
        "comment": "switch 语句分枝过多不利于阅读和维护，这种情况下建议将分枝抽取成函数，再按遵循某种算法的索引结构组织在一起。",
        "config": [
            "maxCasesCount: 分枝数量上限，超过则报出"
            ],
        "tag": "control"
        },
    "ID_switch_brace": {
        "checkPoint": "switch 语句应该用大括号括起来",
        "level": "suggestion",
        "comment": "switch 语句应为包含多条语句的复合语句，且用大括号括起来，否则不应选用 switch 语句。",
        "tag": "control",
        "related": "ID_if_brace,ID_switch_onlyDefault,ID_switch_onlyOneCase",
        "reference": "MISRA C 2004 14.8,MISRA C 2012 15.6,MISRA C++ 2008 6-3-1"
        },
    "ID_switch_forbidNest": {
        "checkPoint": "switch 语句不应嵌套",
        "level": "suggestion",
        "comment": "嵌套的 switch 语句使代码显得复杂，不利于阅读和维护。",
        "tag": "control"
        },
    "ID_try_disorderedHandlers": {
        "checkPoint": "面向派生类的 catch 子句应排在面向基类的 catch 子句之前",
        "level": "error",
        "comment": "以派生类对象为参数的 catch 子句应排在以基类对象为参数的 catch 子句之前，否则后面的 catch 子句会失去作用。",
        "tag": "control",
        "related": "ID_unreachableCode",
        "standard": "ISO/IEC 14882:2003 15.3,ISO/IEC 14882:2011 15.3,ISO/IEC 14882:2011 18.3",
        "reference": "CWE-561,C++ Core Guidelines E.31,MISRA C++ 2008 15-3-6,SEI CERT ERR54-CPP"
        },
    "ID_try_disorderedEllipsis": {
        "checkPoint": "捕获所有异常的 catch(...) 子句应位于最后",
        "level": "error",
        "comment": "如果 catch(...) 子句排在前面，其后面的 catch 子句会失去作用。",
        "tag": "control",
        "related": "ID_unreachableCode",
        "standard": "ISO/IEC 14882:2003 15.3(6),ISO/IEC 14882:2011 15.3(5),ISO/IEC 14882:2011 18.3(5)",
        "reference": "CWE-561,C++ Core Guidelines E.31,MISRA C++ 2008 15-3-7"
        },
    "ID_try_forbidNest": {
        "checkPoint": "不应嵌套 try-catch 语句",
        "level": "suggestion",
        "comment": "嵌套的 try-catch 语句使代码显得复杂，不利于阅读和维护。",
        "tag": "control",
        "reference": "C++ Core Guidelines E.17"
        },
    "ID_catch_value": {
        "checkPoint": "通过引用捕获异常",
        "level": "warning",
        "comment": "通过值捕获异常可能会导致“对象切片”，通过指针捕获异常会增加内存管理成本，通过引用捕获异常才是最合理的方式。",
        "tag": "exception",
        "related": "ID_catch_slicing,ID_throwPointer",
        "reference": "C++ Core Guidelines E.15,C++ Core Guidelines ES.63,MISRA C++ 2008 15-3-5,SEI CERT ERR61-CPP"
        },
    "ID_catch_slicing": {
        "checkPoint": "捕获异常时不应产生对象切片问题",
        "level": "warning",
        "comment": "通过值捕获多态类的异常对象会使其多态性失效，使异常被错误处理。",
        "tag": "exception",
        "related": "ID_catch_value,ID_objectSlicing",
        "reference": "C++ Core Guidelines C.145,C++ Core Guidelines ES.63"
        },
    "ID_catch_generic": {
        "checkPoint": "不应捕获过于宽泛的异常",
        "level": "warning",
        "comment": "捕获过于宽泛的异常，如捕获 std::exception、std::logic_error、std::runtime_error 等类型的异常，或使用 catch(...) 子句捕获所有异常，会使异常处理失去针对性，而且很可能会将本不应处理的异常一并捕获。",
        "tag": "exception",
        "related": "ID_throwGenericException",
        "reference": "CWE-396"
        },
    "ID_catch_nonExceptionType": {
        "checkPoint": "不应捕获非异常类型的对象",
        "level": "warning",
        "comment": "整数、字符串等非异常类的对象不应被当作异常捕获，否则意味着异常相关的设计是不健全的。",
        "tag": "exception",
        "related": "ID_throwNonExceptionType",
        "reference": "C++ Core Guidelines E.14"
        },
    "ID_catch_justRethrow": {
        "checkPoint": "捕获异常后不应直接再次抛出异常",
        "level": "warning",
        "comment": "捕获异常后将其直接再次抛出是没有意义的，还会造成不必要的开销。",
        "tag": "exception"
        },
    "ID_missingDestructor": {
        "checkPoint": "存在拷贝构造函数或拷贝赋值运算符时，不应缺少析构函数",
        "level": "warning",
        "comment": "存在拷贝构造函数或拷贝赋值运算符时，不应缺少析构函数。",
        "tag": "type",
        "related": "ID_missingCopyConstructor,ID_missingCopyAssignOperator,ID_violateRuleOfFive",
        "reference": "C++ Core Guidelines C.21,C++ Core Guidelines C.30,C++ Core Guidelines C.33"
        },
    "ID_missingCopyConstructor": {
        "checkPoint": "存在析构函数或拷贝赋值运算符时，不应缺少拷贝构造函数",
        "level": "warning",
        "comment": "存在析构函数或拷贝赋值运算符时，不应缺少拷贝构造函数。",
        "tag": "type",
        "related": "ID_missingDestructor,ID_missingCopyAssignOperator,ID_violateRuleOfFive",
        "reference": "C++ Core Guidelines C.21"
        },
    "ID_violateRuleOfZero": {
        "checkPoint": "避免重复实现由默认拷贝、移动、析构函数完成的功能",
        "level": "warning",
        "comment": "当类只负责成员对象的组合而没有特殊的复制、移动、析构需求时，不应定义相关函数。",
        "tag": "type",
        "related": "ID_violateRuleOfFive",
        "reference": "C++ Core Guidelines C.21"
        },
    "ID_missingCopyAssignOperator": {
        "checkPoint": "存在拷贝构造函数或析构函数时，不应缺少拷贝赋值运算符",
        "level": "warning",
        "comment": "存在拷贝构造函数或析构函数时，不应缺少拷贝赋值运算符。",
        "tag": "type",
        "related": "ID_missingDestructor,ID_missingCopyConstructor,ID_violateRuleOfFive",
        "reference": "C++ Core Guidelines C.21"
        },
    "ID_violateRuleOfFive": {
        "checkPoint": "存在任一拷贝、移动、析构相关的函数时，应定义所有相关函数",
        "level": "warning",
        "comment": "存在任一拷贝、移动、析构相关的函数时，应定义所有相关函数。",
        "tag": "type",
        "related": "ID_missingCopyConstructor,ID_missingCopyAssignOperator,ID_missingDestructor,ID_violateRuleOfZero",
        "reference": "C++ Core Guidelines C.21"
        },
    "ID_missingExplicitConstructor": {
        "checkPoint": "可接受一个参数的构造函数需用 explicit 关键字限定",
        "level": "suggestion",
        "comment": "为了避免意料之外的类型转换，可接受一个参数的构造函数应该用 explicit 关键字限定。",
        "tag": "type",
        "related": "ID_missingExplicitConvertor",
        "reference": "C++ Core Guidelines C.46,MISRA C++ 2008 12-1-3"
        },
    "ID_missingExplicitConvertor": {
        "checkPoint": "重载的类型转换运算符需用 explicit 关键字限定",
        "level": "suggestion",
        "comment": "为了避免意料之外的类型转换，重载的类型转换运算符需用 explicit 关键字限定。",
        "tag": "type",
        "related": "ID_missingExplicitConstructor",
        "reference": "C++ Core Guidelines C.164"
        },
    "ID_unsuitableAssignOperator": {
        "checkPoint": "抽象类禁用拷贝和移动赋值运算符",
        "level": "warning",
        "comment": "抽象类只能作为基类，没有独立的对象，调用拷贝或移动赋值运算符会造成数据不完整。",
        "tag": "type",
        "reference": "C++ Core Guidelines C.67,MISRA C++ 2008 12-8-2"
        },
    "ID_excessiveExplicit": {
        "checkPoint": "不应过度使用 explicit 关键字",
        "level": "warning",
        "comment": "对类的拷贝、移动以及不接受 1 个参数的构造函数一般不用 explicit 限定，否则有损代码的易用性和可扩展性。",
        "tag": "type",
        "reference": "C++ Core Guidelines C.46"
        },
    "ID_tooManyFields": {
        "checkPoint": "数据成员的数量应在规定范围之内",
        "level": "warning",
        "comment": "类或联合体的数据成员过多意味着一个逻辑或功能单位承担了过多的职责，违反了模块化设计理念，是难以维护的。",
        "config": [
            "maxClassFieldsCount: 类数据成员的数量上限，超过则报出",
            "maxUnionFieldsCount: 联合体数据成员的数量上限，超过则报出"
            ],
        "tag": "type"
        },
    "ID_plainNumericChar": {
        "checkPoint": "参与数值运算的 char 对象应显式声明 signed 或 unsigned",
        "level": "warning",
        "comment": "char 类型是否有符号由实现定义，为了提高可移植性并规避意料之外的错误，参与数值运算的 char 对象应显式声明符号属性。",
        "tag": "declaration",
        "standard": "ISO/IEC 9899:1999 6.2.5(3 15)-implementation,ISO/IEC 9899:2011 6.2.5(3 15)-implementation,ISO/IEC 14882:2003 3.9.1(1)-implementation,ISO/IEC 14882:2011 3.9.1(1)-implementation",
        "reference": "MISRA C++ 2008 5-0-11,SEI CERT INT07-C"
        },
    "ID_plainBinaryChar": {
        "checkPoint": "字节的类型应为 std::byte 或 unsigned char",
        "level": "warning",
        "comment": "字节等二进制概念不应受对齐方式或符号位的干扰，字节的类型应为 std::byte 或 unsigned char。",
        "tag": "declaration",
        "related": "ID_plainNumericChar,ID_bitwiseOperOnSigned",
        "standard": "ISO/IEC 9899:1999 6.2.5(3 15)-implementation,ISO/IEC 9899:2011 6.2.5(3 15)-implementation,ISO/IEC 14882:2003 3.9.1(1)-implementation,ISO/IEC 14882:2011 3.9.1(1)-implementation"
        },
    "ID_uselessQualifier": {
        "checkPoint": "枚举类型的底层类型不应为 const 或 volatile",
        "level": "warning",
        "comment": "将 enum 或 enum class 的底层类型（underlying type）设为 const 或 volatile 是没有意义的，会被编译器忽略，属于语言运用错误。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2011 7.2(2),ISO/IEC 14882:2011 10.2(2)"
        },
    "ID_duplicateEnumerator": {
        "checkPoint": "同类枚举项的值不应相同",
        "level": "warning",
        "comment": "枚举项用于标记不同的事物，名称不同但值相同的枚举项往往意味着错误。",
        "tag": "type",
        "reference": "C++ Core Guidelines Enum.8,MISRA C 2012 8.12"
    },
    "ID_casualInitialization": {
        "checkPoint": "合理初始化各枚举项",
        "level": "suggestion",
        "comment": "合理初始化各枚举项。",
        "tag": "type",
        "related": "ID_duplicateEnumerator",
        "reference": "MISRA C 2004 9.3,MISRA C++ 2008 8-5-3"
        },
    "ID_forbidUnscopedEnum": {
        "checkPoint": "用 enum class 取代 enum",
        "level": "suggestion",
        "comment": "传统 C 枚举没有有效的类型和作用域控制，极易造成类型混淆和名称冲突，在 C++ 语言中建议改用 enum class。",
        "tag": "type",
        "standard": "ISO/IEC 14882:2011 7.2(2),ISO/IEC 14882:2017 10.2(2)",
        "reference": "C++ Core Guidelines Enum.3"
        },
    "ID_forbidUnnamedEnum": {
        "checkPoint": "不应使用匿名枚举声明",
        "level": "suggestion",
        "comment": "匿名枚举声明相当于在当前作用域定义常量，类型不够明确，而且如果无法确定枚举类型的名称，也意味着各枚举项不应聚为一类。",
        "tag": "type",
        "reference": "C++ Core Guidelines Enum.6"
        },
    "ID_forbidNonBasicField": {
        "checkPoint": "联合体内禁用非基本类型的对象",
        "level": "warning",
        "comment": "因为联合体成员之间共享内存地址，所以成员具有构造或析构函数时会导致混乱。",
        "tag": "type",
        "standard": "ISO/IEC 14882:1998 9.5(1),ISO/IEC 14882:2003 9.5(1),ISO/IEC 14882:2011 9.5(2 3 4)"
        },
    "ID_forbidNakedUnion": {
        "checkPoint": "禁用在类之外定义的联合体",
        "level": "suggestion",
        "comment": "联合体各成员共享存储地址，易引发意料之外的错误。如果一定要使用联合体，需对其进行一定的封装，避免对成员的错误访问。",
        "tag": "type",
        "related": "ID_forbidUnion",
        "reference": "C++ Core Guidelines C.181,MISRA C 2004 18.4,MISRA C 2012 19.2,MISRA C++ 2008 9-5-1"
        },
    "ID_forbidUnion": {
        "checkPoint": "禁用联合体",
        "level": "suggestion",
        "comment": "联合体各成员共享存储地址，是一种对类型理念的破坏。",
        "tag": "type",
        "related": "ID_forbidNakedUnion",
        "reference": "MISRA C 2004 18.4,MISRA C 2012 19.2,MISRA C++ 2008 9-5-1"
        },
    "ID_deprecatedDefaultArgument": {
        "checkPoint": "不建议虚函数的参数有默认值",
        "level": "suggestion",
        "comment": "虚函数参数的默认值不受多态规则控制，通过基类指针或引用调用派生类重写的虚函数时，默认值仍采用基类中的定义，易造成混淆，故不建议虚函数的参数有默认值。",
        "tag": "declaration",
        "related": "ID_inconsistentDefaultArgument",
        "standard": "ISO/IEC 14882:2003 8.3.6(10),ISO/IEC 14882:2011 8.3.6(10),ISO/IEC 14882:2017 11.3.6(10)",
        "reference": "CWE-628,C++ Core Guidelines C.140,MISRA C++ 2008 8-3-1"
        },
    "ID_inconsistentDefaultArgument": {
        "checkPoint": "虚函数参数的默认值应与基类中声明的一致",
        "level": "error",
        "comment": "虚函数参数的默认值不受多态规则控制，通过基类指针或引用调用派生类重写的虚函数时，默认值仍采用基类中的定义。",
        "tag": "declaration",
        "related": "ID_deprecatedDefaultArgument",
        "standard": "ISO/IEC 14882:2003 8.3.6(10),ISO/IEC 14882:2011 8.3.6(10),ISO/IEC 14882:2017 11.3.6(10)",
        "reference": "CWE-628,C++ Core Guidelines C.140,MISRA C++ 2008 8-3-1"
        },
    "ID_complexDeclaration": {
        "checkPoint": "不应采用复杂的声明",
        "level": "suggestion",
        "comment": "复杂的声明可读性较差，容易造成理解上的偏差。",
        "tag": "declaration"
        },
    "ID_tooManyPtrLevel": {
        "checkPoint": "声明中不应包含过多的指针嵌套",
        "level": "suggestion",
        "comment": "指针嵌套层级过多意味着指针的解引用逻辑过于复杂，相关代码将难以理解，指针嵌套不宜超过 2 级。",
        "config": [
            "maxPtrLevel: 指针嵌套的最大层数，超过则报出"
            ],
        "tag": "declaration",
        "related": "ID_complexDeclaration",
        "reference": "MISRA C 2004 17.5,MISRA C 2012 18.5"
        },
    "ID_staticNotUsed": {
        "checkPoint": "不应存在没有被用到的静态声明",
        "level": "warning",
        "comment": "没有被用到的静态声明往往是没有意义的，应删除或修正引用关系。",
        "tag": "declaration",
        "related": "ID_unreachableCode",
        "reference": "MISRA C++ 2008 0-1-10"
        },
    "ID_privateNotUsed": {
        "checkPoint": "不应存在没有被用到的 private 成员",
        "level": "warning",
        "comment": "没有被用到的 private 成员是没有意义的，应删除或修正引用关系。",
        "tag": "declaration",
        "related": "ID_unreachableCode",
        "reference": "MISRA C++ 2008 0-1-10"
        },
    "ID_missingParamName": {
        "checkPoint": "函数原型声明中的参数应具有合理的名称",
        "level": "suggestion",
        "comment": "参数的名称是其用途的直接说明，合理的名称可显著提高可读性。",
        "tag": "declaration",
        "reference": "MISRA C 2004 16.3,MISRA C 2012 8.2"
        },
    "ID_obsoleteStdFunction": {
        "checkPoint": "避免使用已过时的标准库组件",
        "level": "warning",
        "comment": "已过时的标准库组件会被语言标准弃用，应改用更完善的替代方法。",
        "tag": "declaration",
        "related": "ID_obsoleteFunction",
        "standard": "ISO/IEC 14882:2011 D.6-deprecated,ISO/IEC 14882:2011 D.7-deprecated,ISO/IEC 14882:2011 D.8-deprecated,ISO/IEC 14882:2011 D.9-deprecated,ISO/IEC 14882:2011 D.10-deprecated,ISO/IEC 14882:2011 D.11-deprecated,ISO/IEC 14882:2017 20.5.4.3.1(1)"
        },
    "ID_mixedDeclarations": {
        "checkPoint": "不应将不同类别的声明写在一个语句中",
        "level": "suggestion",
        "comment": "将对象、指针、引用、数组、函数等不同类别的声明写入一个语句可读性较差，易引起误解。",
        "tag": "declaration",
        "related": "ID_tooManyDeclarators",
        "reference": "C++ Core Guidelines ES.10"
        },
    "ID_mixedTypeObjDefinition": {
        "checkPoint": "不应将类型定义和对象声明写在一个语句中",
        "level": "suggestion",
        "comment": "将类型定义和对象声明写在一个语句中可读性较差，应分开书写。",
        "tag": "declaration",
        "reference": "C++ Core Guidelines C.7"
        },
    "ID_tooManyDeclarators": {
        "checkPoint": "在一个语句中不应声明多个对象或函数",
        "level": "suggestion",
        "comment": "在一个语句中声明多个对象或函数不利于阅读和维护，建议在一个语句中只声明一个对象或函数。",
        "config": [
            "maxLocalDeclaratorCount: 局部作用域中一个语句能声明的对象个数上限，超过则报出",
            "maxMemberDeclaratorCount: 类或结构体中一个语句能声明的对象个数上限，超过则报出",
            "maxGlobalDeclaratorCount: 全局及命名空间作用域中一个语句能声明的对象个数上限，超过则报出",
            "simpleDeclaratorLengthThreshold: 声明字符数量阈值，超过此值则判其应在单独的语句中声明"
            ],
        "tag": "declaration",
        "related": "ID_mixedDeclarations",
        "reference": "C++ Core Guidelines ES.10,MISRA C++ 2008 8-0-1"
        },
    "ID_sandwichedModifier": {
        "checkPoint": "const、volatile 等关键字不应出现在基本类型名称的中间",
        "level": "warning",
        "comment": "某些基本类型名称可由多个符号组成，const、volatile 等关键字不应出现在类型名称的中间，否则可读性较差。",
        "tag": "declaration",
        "standard":"ISO/IEC 9899:1999 6.7(1),ISO/IEC 9899:1999 6.7.2(1),ISO/IEC 9899:2011 6.7(1),ISO/IEC 9899:2011 6.7.2(1),ISO/IEC 14882:2003 A.6,ISO/IEC 14882:2011 A.6",
        "related": "ID_badQualifierPosition,ID_badSpecifierPosition",
        "reference": "C++ Core Guidelines NL.26"
    },
    "ID_badQualifierPosition": {
        "checkPoint": "const、volatile 限定类型时的位置应统一",
        "level": "suggestion",
        "comment": "语言允许 const、volatile 等关键字出现在类型名称的左侧，也可以出现在其右侧，甚至可以出现在基本类型名称的中间，应对其位置进行统一规范以提高可读性。",
        "tag": "declaration",
        "config": [
            "positionScheme: const、volatile 的位置方案，对应说明中的 1、2、3 号方案",
            "volatileInFront: volatile 是否应写在 const 的前面，如果值为 false 则应写在后面，不设此项则不考虑相关顺序"
            ],
        "standard":"ISO/IEC 9899:1999 6.7(1),ISO/IEC 9899:1999 6.7.2(1),ISO/IEC 9899:2011 6.7(1),ISO/IEC 9899:2011 6.7.2(1),ISO/IEC 14882:2003 A.6,ISO/IEC 14882:2011 A.6",
        "related": "ID_sandwichedModifier,ID_badSpecifierPosition",
        "reference": "C++ Core Guidelines NL.26"
        },
    "ID_badSpecifierPosition": {
        "checkPoint": "inline、virtual、static、typedef 等关键字的位置应统一",
        "level": "suggestion",
        "comment": "语言允许 inline、virtual、static、typedef 等关键字出现在类型名称的左侧，也可以出现在其右侧，甚至可以出现在基本类型名称的中间，应对其位置进行统一规范以提高可读性。",
        "tag": "declaration",
        "standard":"ISO/IEC 9899:1999 6.7(1),ISO/IEC 9899:1999 6.7.2(1),ISO/IEC 9899:2011 6.7(1),ISO/IEC 9899:2011 6.7.2(1),ISO/IEC 14882:2003 A.6,ISO/IEC 14882:2011 A.6",
        "related": "ID_sandwichedModifier,ID_badQualifierPosition"
        },
    "ID_hideLocal": {
        "checkPoint": "局部名称不应被覆盖",
        "level": "warning",
        "comment": "不应在嵌套的作用域中声明相同的名称，否则干扰阅读，极易引起误解。",
        "tag": "declaration",
        "reference": "CWE-1109,C++ Core Guidelines ES.12,MISRA C 2004 5.2,MISRA C 2012 5.3,MISRA C++ 2008 2-10-2"
        },
    "ID_hideMember": {
        "checkPoint": "成员名称不应被覆盖",
        "level": "warning",
        "comment": "成员函数内的局部名称与成员名称相同会干扰阅读，易引起误解。",
        "tag": "declaration",
        "reference": "CWE-1109,MISRA C 2004 5.2,MISRA C 2012 5.3,MISRA C++ 2008 2-10-2"
        },
    "ID_hideGlobal": {
        "checkPoint": "全局名称不应被覆盖",
        "level": "warning",
        "comment": "局部、成员名称不应与全局或命名空间内的名称相同，否则干扰阅读，易引起误解。",
        "tag": "declaration",
        "reference": "CWE-1109,MISRA C 2004 5.2,MISRA C 2012 5.3,MISRA C++ 2008 2-10-2"
        },
    "ID_constStrToNonConstPtr": {
        "checkPoint": "指向常量字符串的指针应使用 const 声明",
        "level": "warning",
        "comment": "常量字符串与非常量字符串指针的隐式转换是不安全的，一旦相关内存被修改会导致标准未定义的行为，这种转换在 C++ 标准中是过时的，在 C 代码中也不应出现。",
        "tag": "declaration",
        "standard": "ISO/IEC 9899:1999 6.4.5(6)-undefined,ISO/IEC 9899:2011 6.4.5(7)-undefined,ISO/IEC 14882:1998 D.4(1)-deprecated,ISO/IEC 14882:2003 2.13.4(2)-undefined,ISO/IEC 14882:2003 D.4(1)-deprecated,ISO/IEC 14882:2011 2.14.5(12)-undefined,ISO/IEC 14882:2017 5.13.5(16)-undefined",
        "related": "ID_nonConstUnmodified",
        "reference": "MISRA C 2012 7.4"
        },
    "ID_virtualComparison": {
        "checkPoint": "比较运算符不应为虚函数",
        "level": "warning",
        "comment": "重载的比较运算符很难正确触发 C++ 的多态机制，将其设为虚函数很可能引发意料之外的错误。",
        "tag": "declaration",
        "reference": "C++ Core Guidelines C.87"
        },
    "ID_virtualAssignment": {
        "checkPoint": "拷贝和移动赋值运算符不应为虚函数",
        "level": "warning",
        "comment": "拷贝和移动赋值运算符的参数应分别为所属类的左值和右值引用，这类运算符即使是虚函数也不便于被重写。",
        "tag": "declaration",
        "related": "ID_nonStdAssignmentRetType",
        "standard": "ISO/IEC 14882:2003 12.8(9),ISO/IEC 14882:2011 12.8(17),ISO/IEC 14882:2011 12.8(19)",
        "reference": "C++ Core Guidelines C.60,C++ Core Guidelines C.63"
        },
    "ID_illCopyConstructorParam": {
        "checkPoint": "拷贝构造函数的参数应为同类对象的 const 左值引用",
        "level": "warning",
        "comment": "如果构造函数的参数不是同类对象的左值引用，则不构成拷贝构造函数，拷贝构造函数不应具备复制之外的功能，故其参数不应被修改，应受 const 关键字限制。",
        "tag": "declaration",
        "related": "ID_sideEffectCopyConstructor,ID_nonStdCopyAssignmentParam,ID_nonConstUnmodified"
    },
    "ID_nonStdCopyAssignmentParam": {
        "checkPoint": "拷贝赋值运算符的参数应为同类对象的 const 左值引用",
        "level": "warning",
        "comment": "拷贝赋值运算符的参数不应按值传递，否则会产生不必要的复制开销以及“对象切片”等问题。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2003 12.8(9),ISO/IEC 14882:2011 12.8(17)",
        "related": "ID_illCopyConstructorParam,ID_nonConstUnmodified",
        "reference": "C++ Core Guidelines C.60"
    },
    "ID_illMoveConstructorParam": {
        "checkPoint": "移动构造函数的参数应为同类对象的非 const 右值引用",
        "level": "warning",
        "comment": "移动构造意在将参数的数据转移到当前对象中，故参数应为右值引用，且不应受 const 关键字限制。",
        "tag": "declaration",
        "related": "ID_nonStdMoveAssignmentParam"
    },
    "ID_nonStdMoveAssignmentParam": {
        "checkPoint": "移动赋值运算符的参数应为同类对象的非 const 右值引用",
        "level": "warning",
        "comment": "移动赋值意在将参数的数据转移到当前对象中，故参数应为右值引用，且不应受 const 关键字限制。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2011 12.8(19),ISO/IEC 14882:2017 15.8.2(3)",
        "reference": "C++ Core Guidelines C.63"
    },
    "ID_illOperatorRetType": {
        "checkPoint": "重载运算符的返回类型应与内置运算符相符",
        "level": "warning",
        "comment": "为了便于调用者使用，并满足泛型编程的要求，重载运算符的返回类型应与内置运算符相符。",
        "tag": "declaration",
        "related": "ID_nonStdAssignmentRetType"
    },
    "ID_nonStdAssignmentRetType": {
        "checkPoint": "赋值运算符应返回所属类的非 const 左值引用",
        "level": "warning",
        "comment": "赋值运算符应返回所属类不受 const 关键字限定的左值引用，以便调用者使用并满足泛型编程的要求。",
        "tag": "declaration",
        "related": "ID_illOperatorRetType",
        "standard": "ISO/IEC 14882:2003 12.8(10),ISO/IEC 14882:2011 12.8(22)",
        "reference": "C++ Core Guidelines F.47,C++ Core Guidelines C.60,C++ Core Guidelines C.63"
    },
    "ID_mainReturnsNonInt": {
        "checkPoint": "main 函数的返回类型只应为 int",
        "level": "warning",
        "comment": "main 函数的返回值可作为整个进程执行情况的总结，按惯例返回 0 或 EXIT_SUCCESS 表示执行成功，非 0 或 EXIT_FAILURE 表示执行失败，main 函数的返回值会作为标准 exit 函数的参数。",
        "tag": "function",
        "standard": "ISO/IEC 9899:1999 5.1.2.2.1(1)-implementation,ISO/IEC 9899:1999 5.1.2.2.3(1)-unspecified,ISO/IEC 9899:2011 5.1.2.2.1(1)-implementation,ISO/IEC 9899:2011 5.1.2.2.3(1)-unspecified,ISO/IEC 14882:2003 3.6.1(2)-implementation,ISO/IEC 14882:2011 3.6.1(2)-implementation",
        "reference": "C++ Core Guidelines F.46"
        },
    "ID_missingNamespace": {
        "checkPoint": "为代码设定合理的命名空间",
        "level": "warning",
        "comment": "命名空间是 C++ 项目的必要组成结构，可有效规避名称冲突等问题。",
        "tag": "global",
        "related": "ID_usingNamespaceInHeader,ID_forbidUsingDirectives",
        "reference": "MISRA C++ 2008 7-3-1"
        },
    "ID_nonGlobalMain": {
        "checkPoint": "main 函数只应处于全局作用域中",
        "level": "warning",
        "comment": "main 函数作为程序的入口，链接器需对其特殊处理，不应受命名空间等作用域的限制。",
        "tag": "global",
        "standard": "ISO/IEC 14882:2003 3.6.1(1),ISO/IEC 14882:2011 3.6.1(1)",
        "reference": "MISRA C++ 2008 7-3-2"
        },
    "ID_illFormedMain": {
        "checkPoint": "main 函数不应被调用、重载或被 inline、static 等关键字限定",
        "level": "warning",
        "comment": "main 函数作为程序的入口是一种特殊的函数，其链接性由实现定义，不应被调用、重载或被任何函数限定符修饰。",
        "tag": "function",
        "standard": "ISO/IEC 9899:1999 6.7.4(4),ISO/IEC 9899:2011 6.7.4(4),ISO/IEC 14882:2003 3.6.1(2 3)-implementation,ISO/IEC 14882:2011 3.6.1(2 3)-implementation,ISO/IEC 14882:2017 6.6.1(2 3)-implementation"
        },
    "ID_constLiteralReference": {
        "checkPoint": "对常量的定义不应为引用",
        "level": "warning",
        "comment": "虽然 C++ 语言十分灵活，可以通过多种方式达到同一种目的，但应该选择最简洁且通俗易懂的方式实现。",
        "tag": "declaration"
        },
    "ID_forbidEnumBitfield": {
        "checkPoint": "不应对枚举对象声明位域",
        "level": "warning",
        "comment": "枚举类型是否有符号由实现定义，而且符号位与位域结合易导致意料之外的错误。",
        "tag": "declaration",
        "related": "ID_improperBitfieldType,ID_singleSignedBitfield",
        "standard": "ISO/IEC 9899:1999 6.7.2.2(4)-implementation,ISO/IEC 9899:2011 6.7.2.2(4)-implementation,ISO/IEC 14882:2011 7.2(6)-implementation,ISO/IEC 14882:2017 10.2(7)-implementation",
        "reference": "MISRA C++ 2008 9-6-3"
        },
    "ID_forbidFlexibleArray": {
        "checkPoint": "禁用柔性数组",
        "level": "suggestion",
        "comment": "柔性数组（flexible array）一般是指结构体最后不完整定义的数组成员，表示不占用空间的指针，这种数组在 C99 中有所定义，但不在 C++ 标准之中，在 C++ 代码中不应使用。",
        "tag": "declaration",
        "standard": "ISO/IEC 9899:1999 6.7.2.1(16),ISO/IEC 9899:2011 6.7.2.1(18)",
        "reference": "MISRA C 2012 18.7"
        },
    "ID_improperBitfieldType": {
        "checkPoint": "对位域声明合理的类型",
        "level": "warning",
        "comment": "为了提高可移植性和可维护性，应对位域声明合理的类型。",
        "config": [
            "bitfieldMustBeUnsigned: 位域类型是否必须为无符号整型",
            "bitfieldMustBeStdInt: 位域类型是否必须为 stdint.h 或 cstdint 中定义的类型"
            ],
        "tag": "declaration",
        "standard": "ISO/IEC 9899:1999 J.3.9(1)-implementation,ISO/IEC 9899:2011 J.3.9(1)-implementation,ISO/IEC 14882:2003 9.6(3)-implementation,ISO/IEC 14882:2011 9.6(3)-implementation",
        "reference": "MISRA C 2004 6.4,MISRA C 2012 6.1,MISRA C++ 2008 9-6-2"
        },
    "ID_exceededBitfield": {
        "checkPoint": "位域长度不应超过类型长度",
        "level": "warning",
        "comment": "位域长度超过类型长度易误导维护者，而且也可能是笔误。",
        "tag": "declaration",
        "standard": "ISO/IEC 9899:1999 6.7.2.1(3),ISO/IEC 9899:2011 6.7.2.1(4),ISO/IEC 14882:2003 9.6(1),ISO/IEC 14882:2011 9.6(1)"
        },
    "ID_singleSignedBitfield": {
        "checkPoint": "有符号整型对象的位域长度不应为 1",
        "level": "warning",
        "comment": "有符号整型对象的位域长度如果为 1 表示只有一个比特位，而该比特位是符号位，极易造成意料之外的错误。",
        "tag": "declaration",
        "reference": "MISRA C 2012 6.2,MISRA C++ 2008 9-6-4"
        },
    "ID_invalidFinal": {
        "checkPoint": "不应将 union 设为 final",
        "level": "warning",
        "comment": "在 C++ 语言中，union 不可作为基类，将 union 声明为 final 是没有意义的，属于语言运用错误。",
        "standard": "ISO/IEC 14882:2011 9.5(2),ISO/IEC 14882:2017 12.3(3)",
        "tag": "declaration"
        },
    "ID_virtualInFinal": {
        "checkPoint": "final 类中不应声明虚函数",
        "level": "warning",
        "comment": "final 类不再产生派生类，其中的虚函数也不会再被重写，故不应声明虚函数。",
        "standard": "ISO/IEC 14882:2011 9(3),ISO/IEC 14882:2017 12(3)",
        "tag": "declaration"
        },
    "ID_exceptionUnsafe": {
        "checkPoint": "保证异常安全",
        "level": "warning",
        "comment": "保证异常安全。",
        "tag": "exception",
        "related": "ID_resourceLeak,ID_ownerlessResource,ID_throwInSwap",
        "reference": "SEI CERT ERR56-CPP,Effective C++ item 29"
        },
    "ID_throwWhileThrowing": {
        "checkPoint": "异常类的拷贝构造函数不可抛出异常",
        "level": "error",
        "comment": "异常类的拷贝构造函数抛出异常违反异常处理机制，导致程序异常终止。",
        "tag": "exception",
        "standard": "ISO/IEC 14882:2003 15.1(3),ISO/IEC 14882:2011 15.1(3 7),ISO/IEC 14882:2017 18.1(3 7)",
        "related": "ID_exceptionInException",
        "reference": "SEI CERT ERR60-CPP"
        },
    "ID_exceptionInException": {
        "checkPoint": "异常类的构造函数和异常信息相关的函数不应抛出异常",
        "level": "warning",
        "comment": "创建、复制异常对象以及获取异常信息时不应再抛出异常，否则不利于异常的定位与处理。",
        "tag": "exception",
        "related": "ID_throwWhileThrowing",
        "standard": "ISO/IEC 14882:2003 18.6.1,ISO/IEC 14882:2011 18.8.1",
        "reference": "MISRA C++ 2008 15-1-1"
        },
    "ID_throwOutOfMain": {
        "checkPoint": "全局对象的初始化过程不可抛出异常",
        "level": "warning",
        "comment": "在全局对象初始化过程中抛出的异常没有被处理的机会，导致程序异常终止。",
        "tag": "exception",
        "related": "ID_uncaughtException",
        "standard": "ISO/IEC 14882:2003 15.3(9)-implementation,ISO/IEC 14882:2003 15.5.1(2)-implementation,ISO/IEC 14882:2011 15.3(9)-implementation,ISO/IEC 14882:2011 15.5.1(2)-implementation",
        "reference": "MISRA C++ 2008 15-3-1,SEI CERT ERR58-CPP"
        },
    "ID_uncaughtException": {
        "checkPoint": "处理所有异常",
        "level": "warning",
        "comment": "如果被抛出的异常没有被相应的 catch 子句处理会引发 std::terminate 函数的执行，使程序异常终止。",
        "tag": "exception",
        "related": "ID_throwOutOfMain,ID_implementationDefinedFunction",
        "standard": "ISO/IEC 14882:2003 15.3(9)-implementation,ISO/IEC 14882:2003 15.5.1(2)-implementation,ISO/IEC 14882:2011 15.3(9)-implementation,ISO/IEC 14882:2011 15.5.1(2)-implementation",
        "reference": "MISRA C++ 2008 15-3-2,MISRA C++ 2008 15-3-4,SEI CERT ERR51-CPP"
        },
    "ID_forbidThrowSpecification": {
        "checkPoint": "禁用动态异常说明",
        "level": "warning",
        "comment": "用 throw 关键字声明的“动态异常说明（dynamic exception specification）”已过时，应使用 noexcept 关键字完成异常说明。",
        "config": [
            "forbidEmptyThrowSpecification: 是否放过空 throw 异常说明"
            ],
        "tag": "exception",
        "standard": "ISO/IEC 14882:2011 D.4-deprecated,ISO/IEC 14882:2017 D.3-deprecated",
        "reference": "C++ Core Guidelines E.12,C++ Core Guidelines E.30"
        },
    "ID_forbidVariadicFunction": {
        "checkPoint": "禁用可变参数列表",
        "level": "warning",
        "comment": "可变参数列表对参数的类型和数量缺乏有效的限定和控制，是公认的不安全因素。",
        "tag": "declaration",
        "related": "ID_badParmN,ID_badVaArgType",
        "standard": "ISO/IEC 14882:2003 5.2.2(7)-undefined,ISO/IEC 14882:2011 5.2.2(7)-implementation",
        "reference": "C++ Core Guidelines ES.34,C++ Core Guidelines F.55,MISRA C 2004 16.1,MISRA C 2012 17.1,MISRA C++ 2008 8-4-1"
        },
    "ID_redundantVirtual": {
        "checkPoint": "override 或 final 关键字不应与 virtual 关键字同时出现在声明中",
        "level": "suggestion",
        "comment": "只应在定义新的虚函数时使用 virtual 关键字，当重写虚函数时，应使用 override 或 final 关键字，不应再出现 virtual 关键字，使代码更清晰简洁。",
        "tag": "declaration",
        "reference": "C++ Core Guidelines C.128"
        },
    "ID_redundantOverride": {
        "checkPoint": "override 和 final 关键字不应同时出现在声明中",
        "level": "suggestion",
        "comment": "final 表示不可重写的重写，override 表示可再次重写的重写，这两个关键字不应同时出现在声明中。",
        "tag": "declaration",
        "reference": "C++ Core Guidelines C.128"
        },
    "ID_forbidBitfield": {
        "checkPoint": "禁用位域",
        "level": "suggestion",
        "comment": "位域改变了类型约定俗成的取值范围和存储方式，易造成理解上的偏差，增加维护成本，在不受特定协议限制的代码中不应使用位域。",
        "tag": "declaration",
        "standard": "ISO/IEC 9899:1999 J.3.9(1)-implementation,ISO/IEC 9899:2011 J.3.9(1)-implementation,ISO/IEC 14882:2003 9.6(1)-implementation,ISO/IEC 14882:2003 9.6(3),ISO/IEC 14882:2011 9.6(1)-implementation,ISO/IEC 14882:2011 9.6(3),ISO/IEC 14882:2017 12.2.4(1)-implementation,ISO/IEC 14882:2017 12.2.4(3)",
        "related": "ID_exceededBitfield,ID_singleSignedBitfield,ID_bitfieldDataRaces,ID_forbidEnumBitfield"
        },
    "ID_labelNotUsed": {
        "checkPoint": "不应存在没有被用到的标签",
        "level": "warning",
        "comment": "没有被用到的标签意味着 goto 语句的缺失，也可能是残留代码，应当去除。",
        "tag": "declaration",
        "reference": "MISRA C 2012 2.6"
        },
    "ID_forbidRestrictPtr": {
        "checkPoint": "禁用 restrict 指针",
        "level": "warning",
        "comment": "C 语言中的 restrict 指针要求其他指针不能再指向相同区域，有助于编译器优化，但不符合这种限制时会导致标准未定义的行为，相当于增加了误用风险，也增加了测试成本。",
        "tag": "declaration",
        "standard": "ISO/IEC 9899:1999 6.7.3.1(4 9 11)-undefined,ISO/IEC 9899:2011 6.7.3.1(4 9 11)-undefined",
        "reference": "MISRA C 2012 8.14,SEI CERT EXP43-C"
        },
    "ID_forbidStaticArrSize": {
        "checkPoint": "声明数组参数的大小时禁用 static 关键字",
        "level": "warning",
        "comment": "C 语言规定数组作为形式参数时，可用 static 关键字限定大小，要求传入数组的大小不能小于由 static 关键字限定的值，有助于编译器优化，但不符合这种限制时会导致标准未定义的行为，相当于增加了误用风险，也增加了测试成本。",
        "tag": "declaration",
        "standard": "ISO/IEC 9899:1999 6.7.6.3(7),ISO/IEC 9899:2011 6.7.6.3(7)",
        "reference": "MISRA C 2012 17.6"
        },
    "ID_forbidGotoBlocks": {
        "checkPoint": "禁止 goto 语句向嵌套的或无包含关系的作用域跳转",
        "level": "warning",
        "comment": "不同的作用域对应不同的条件约束，在不同的作用域间跳转是对约束的破坏，很容易导致逻辑混乱。",
        "tag": "control",
        "related": "ID_forbidGotoBack,ID_forbidGoto",
        "reference": "MISRA C 2012 15.3,MISRA C++ 2008 6-6-1"
        },
    "ID_forbidGotoBack": {
        "checkPoint": "禁止 goto 语句向前跳转",
        "level": "suggestion",
        "comment": "向先于当前 goto 语句定义的标签跳转，可读性较差，是公认的不良实现。",
        "tag": "control",
        "related": "ID_forbidGotoBlocks,ID_forbidGoto",
        "reference": "MISRA C 2012 15.2,MISRA C++ 2008 6-6-2"
        },
    "ID_forbidGoto": {
        "checkPoint": "禁用 goto 语句",
        "level": "suggestion",
        "comment": "历史表明，goto 语句会破坏程序的结构性规划，很容易导致逻辑混乱且不利于阅读和维护，在非自动生成的、对可读性有要求的代码中，建议禁用 goto 语句。",
        "tag": "control",
        "related": "ID_forbidGotoBlocks,ID_forbidGotoBack",
        "reference": "C++ Core Guidelines ES.76,MISRA C 2012 15.1"
        },
    "ID_forbidAbsPathInHeaderName": {
        "checkPoint": "include 指令中不应使用绝对路径",
        "level": "warning",
        "comment": "绝对路径使代码过分依赖编译环境，意味着项目的编译设置不完善，应使用相对路径。",
        "tag": "precompile"
        },
    "ID_illFormedInclude": {
        "checkPoint": "include 指令应符合标准格式",
        "level": "error",
        "comment": "#include 后只应为 < 头文件路径 > 或 \" 头文件路径 \"，否则会导致标准未定义的行为。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.10.2,ISO/IEC 9899:2011 6.10.2,ISO/IEC 14882:2003 2.8,ISO/IEC 14882:2003 16.2(4)-undefined,ISO/IEC 14882:2003 16.2(4)-implementation,ISO/IEC 14882:2011 2.9,ISO/IEC 14882:2011 16.2(4)-undefined,ISO/IEC 14882:2011 16.2(4)-implementation",
        "related": "ID_nonStandardCharInHeaderName",
        "reference": "MISRA C 2004 19.3,MISRA C 2012 20.3,MISRA C++ 2008 16-2-6"
        },
    "ID_nonStandardCharInHeaderName": {
        "checkPoint": "include 指令中禁用不合规的字符",
        "level": "warning",
        "comment": "字母、数字、下划线、点号之外的字符可能与文件系统存在冲突，也可能导致标准未定义的行为，不应出现在头文件和相关目录名称中。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.4.7(3)-undefined,ISO/IEC 9899:2011 6.4.7(3)-undefined,ISO/IEC 14882:2003 2.8(2)-undefined,ISO/IEC 14882:2011 2.9(2)-implementation",
        "reference": "MISRA C 2004 19.2,MISRA C 2012 20.2,MISRA C++ 2008 16-2-4"
        },
    "ID_forbidBackslashInHeaderName": {
        "checkPoint": "include 指令中不应使用反斜杠",
        "level": "warning",
        "comment": "如果在 include 指令中使用反斜杠，程序的行为在 C 和 C++03 标准中是未定义的，在 C++11 标准中是由实现定义的。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.4.7(3)-undefined,ISO/IEC 9899:2011 6.4.7(3)-undefined,ISO/IEC 14882:2003 2.8(2)-undefined,ISO/IEC 14882:2011 2.9(2)-implementation",
        "reference": "MISRA C++ 2008 16-2-5"
        },
    "ID_forbidCHeaderInCpp": {
        "checkPoint": "C++ 代码不应引用 C 头文件",
        "level": "warning",
        "comment": "为了与 C 语言兼容，C++ 标准库也会提供 C 头文件，但在这种 C 头文件在 C++ 标准中是已过时的。",
        "tag": "precompile",
        "related": "ID_forbiddenHeader",
        "standard": "ISO/IEC 14882:1998 D.5-deprecated,ISO/IEC 14882:2003 D.5-deprecated,ISO/IEC 14882:2011 D.5-deprecated,ISO/IEC 14882:2017 D.5-deprecated",
        "reference": "MISRA C++ 2008 18-0-1"
        },
    "ID_badIncludePosition": {
        "checkPoint": "include 指令应位于文件的起始部分",
        "level": "warning",
        "comment": "include 指令之前的代码只应为预编译指令或注释，否则不利于阅读和维护。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 7.1.2(4),ISO/IEC 9899:2011 7.1.2(4),ISO/IEC 14882:2003 17.4.2.1(3),ISO/IEC 14882:2011 17.6.2.2(3),ISO/IEC 14882:2017 20.5.2.2(3)",
        "reference": "MISRA C 2012 20.1,MISRA C++ 2008 16-0-1"
        },
    "ID_forbiddenHeader": {
        "checkPoint": "禁用不合规的头文件",
        "level": "warning",
        "comment": "已过时的、无意义的或有不良副作用的头文件应禁用。",
        "config": [
            "inC: C 代码中不合规头文件名称",
            "inCpp: C++ 代码中不合规头文件名称"
            ],
        "tag": "precompile",
        "standard": "ISO/IEC 14882:2017 C.5.1(4),ISO/IEC 14882:2017 D.4(1)-deprecated",
        "reference": "MISRA C 2012 21.4,MISRA C 2012 21.5,MISRA C 2012 21.10,MISRA C 2012 21.11,MISRA C 2012 21.12,MISRA C++ 2008 18-0-4,MISRA C++ 2008 18-7-1,MISRA C++ 2008 27-0-1"
        },
    "ID_spaceStyle": {
        "checkPoint": "空格应遵循统一风格",
        "level": "suggestion",
        "comment": "与运算符、标点符、关键字相关的空格应遵循统一风格，过于随意的空格会干扰阅读，甚至形成笔误。",
        "tag": "style",
        "related": "ID_stickyAssignmentOperator"
        },
    "ID_braceStyle": {
        "checkPoint": "大括号应遵循统一风格",
        "level": "suggestion",
        "comment": "大括号应遵循统一的换行和缩进风格，否则不利于阅读和维护，甚至形成笔误。",
        "tag": "style",
        "related": "ID_if_mayBeElseIf"
        },
    "ID_returnSuperfluousConst": {
        "checkPoint": "函数返回值不应为基本类型的常量",
        "level": "warning",
        "comment": "基本类型的函数返回值本来就是不可被修改的右值，不应再受 const 关键字限制。",
        "tag": "function",
        "related": "ID_returnConstObject",
        "standard": "ISO/IEC 14882:2003 3.10(5),ISO/IEC 14882:2011 3.10(1)"
        },
    "ID_nonPODFilling": {
        "checkPoint": "memset 等函数不应作用于非 POD 对象",
        "level": "error",
        "comment": "memset、memcpy、memmove 等具有填充功能的函数不应作用于非“POD”对象，否则会破坏其数据的内在关系。",
        "tag": "buffer",
        "related": "ID_nonPODBinaryCast",
        "reference": "CWE-463,C++ Core Guidelines SL.con.4,C++ Core Guidelines C.90"
        },
    "ID_missingHeaderGuard": {
        "checkPoint": "头文件不应缺少守卫",
        "level": "warning",
        "comment": "以 .h 或 .hpp 为扩展名的头文件应包含头文件守卫。",
        "config": [
            "allowPragmaOnce: 是否允许 #pragma once 作为头文件守卫"
            ],
        "tag": "precompile",
        "reference": "C++ Core Guidelines SF.8,MISRA C 2004 19.15,MISRA C++ 2008 16-2-3"
        },
    "ID_evalOverflow": {
        "checkPoint": "运算结果不应溢出",
        "level": "warning",
        "comment": "溢出即运算结果超出了对应类型的取值范围，使相关数据无法被完整存储，造成数据丢失。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.2.5(9),ISO/IEC 9899:1999 6.5(5)-undefined,ISO/IEC 9899:2011 6.2.5(9),ISO/IEC 9899:2011 6.5(5)-undefined,ISO/IEC 14882:2003 5(5)-undefined,ISO/IEC 14882:2011 5(4)-undefined",
        "reference": "CWE-190,C++ Core Guidelines ES.103,C++ Core Guidelines ES.104"
    },
    "ID_constLogicExpression": {
        "checkPoint": "逻辑表达式及逻辑子表达式不应为常量",
        "level": "warning",
        "comment": "不改变程序流程的常量逻辑表达式是没有意义的，而常量逻辑子表达式则是多余的。",
        "tag": "expression",
        "reference": "CWE-570,CWE-571,MISRA C 2004 13.7,MISRA C 2012 14.3,MISRA C++ 2008 0-1-2"
        },
    "ID_invalidCommaSubExpression": {
        "checkPoint": "逗号表达式的子表达式应具有必要的副作用",
        "level": "warning",
        "comment": "缺少必要副作用的逗号子表达式没有意义，往往意味着逻辑错误。",
        "tag": "expression",
        "related": "ID_forbidCommaExpression"
        },
    "ID_forbidCommaExpression": {
        "checkPoint": "禁用逗号表达式",
        "level": "suggestion",
        "comment": "逗号表达式将多个语句合成一个表达式，不利于阅读且易形成笔误。",
        "config": [
            "allowCommaExpressionInForIteration: 是否放过 for 语句中的逗号表达式"
            ],
        "tag": "expression",
        "reference": "MISRA C 2004 12.10,MISRA C 2012 12.3,MISRA C++ 2008 5-18-1"
        },
    "ID_conflictCondition": {
        "checkPoint": "逻辑子表达式之间不应存在矛盾",
        "level": "error",
        "comment": "相互矛盾的逻辑子表达式会使整个表达式的结果恒为真或恒为假，导致逻辑错误。",
        "tag": "expression",
        "related": "ID_redundantCondition,ID_simplifiableCondition",
        "reference": "CWE-570,CWE-571"
        },
    "ID_illIdentical": {
        "checkPoint": "不应存在无意义的重复子表达式",
        "level": "error",
        "comment": "逻辑与、逻辑或、按位与、按位或的子表达式以及三元表达式的两个分枝不应重复，否则相关运算会失去意义。",
        "tag": "expression",
        "reference": "CWE-682"
        },
    "ID_illComparison": {
        "checkPoint": "参与比较的对象之间应具备合理的大小关系",
        "level": "error",
        "comment": "对象与超出其类型取值范围的值比较，或与取值范围的边界进行无意义的比较属于逻辑错误。",
        "tag": "expression",
        "related": "ID_switch_caseOutOfRange",
        "reference": "CWE-697,CWE-1024,CWE-1025"
        },
    "ID_illPtrStrComparison": {
        "checkPoint": "指针不应与字符串常量直接比较",
        "level": "error",
        "comment": "直接比较指针和字符串常量的结果往往总是 false，应改用字符串比较函数。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.4.5(6)-unspecified,ISO/IEC 9899:2011 6.4.5(7)-unspecified,ISO/IEC 14882:2003 2.13.4(2)-implementation,ISO/IEC 14882:2011 2.14.5(12)-implementation,ISO/IEC 14882:2017 5.13.5(16)-unspecified",
        "reference": "CWE-595,CWE-697,CWE-1024,CWE-1025"
        },
    "ID_illFloatComparison": {
        "checkPoint": "不应使用 == 或 != 判断浮点数是否相等",
        "level": "warning",
        "comment": "不应使用 == 或 != 判断浮点数是否相等。",
        "tag": "expression",
        "reference": "CWE-1025,MISRA C 2004 13.3,MISRA C++ 2008 6-2-2"
        },
    "ID_successiveComparison": {
        "checkPoint": "比较运算不可作为另一个比较运算的直接子表达式",
        "level": "error",
        "comment": "在 C/C++ 语言中，连续的比较运算是没有意义的，本规则是 ID_illBoolOperation 的特化。",
        "tag": "expression",
        "related": "ID_illBoolOperation",
        "reference": "CWE-697,CWE-1024,CWE-1025"
        },
    "ID_illShiftCount": {
        "checkPoint": "移位数量不应超过相关类型比特位的数量",
        "level": "error",
        "comment": "如果移位数量为负数、大于或等于相关类型比特位的数量，会导致标准未定义的行为。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.5.7(3)-undefined,ISO/IEC 9899:2011 6.5.7(3)-undefined,ISO/IEC 14882:2003 5.8(1)-undefined,ISO/IEC 14882:2011 5.8(1)-undefined,ISO/IEC 14882:2017 8.8(1)-undefined",
        "reference": "MISRA C 2012 12.2,MISRA C++ 2008 5-8-1"
        },
    "ID_suspiciousPromotion": {
        "checkPoint": "按位取反需避免由类型提升产生的多余数据",
        "level": "suspicious",
        "comment": "8 位或 16 位整数按位取反时会被提升为 int 等类型，可能会产生非预期的多余数据。",
        "tag": "expression",
        "reference": "MISRA C++ 2008 5-0-10"
    },
    "ID_unexpectedPrecedence": {
        "checkPoint": "注意运算符优先级，避免非预期的结果",
        "level": "warning",
        "comment": "对运算符优先级的错误理解是产生逻辑错误的主要原因之一。",
        "tag": "expression",
        "reference": "CWE-783"
        },
    "ID_illPtrDiff": {
        "checkPoint": "不在同一数组或对象中的地址不可相减或比较大小",
        "level": "warning",
        "comment": "不在同一数组或对象中的地址之间没有逻辑关系，这种地址相减或比较大小属于逻辑错误，也会导致标准未定义或未声明的行为。",
        "tag": "expression",
        "related": "ID_oddPtrZeroComparison",
        "standard": "ISO/IEC 9899:1999 6.5.6(9)-undefined,ISO/IEC 9899:1999 6.5.8(5)-undefined,ISO/IEC 9899:2011 6.5.6(9)-undefined,ISO/IEC 9899:2011 6.5.8(5)-undefined,ISO/IEC 14882:2003 5.7(6)-undefined,ISO/IEC 14882:2003 5.9(2)-unspecified,ISO/IEC 14882:2011 5.7(6)-undefined,ISO/IEC 14882:2011 5.9(2)-unspecified",
        "reference": "C++ Core Guidelines ES.62,MISRA C 2004 17.3,MISRA C 2012 18.3,MISRA C++ 2008 5-0-16,MISRA C++ 2008 5-0-17,MISRA C++ 2008 5-0-18"
        },
    "ID_illBoolOperation": {
        "checkPoint": "bool 值不应参与位运算、大小比较、数值增减",
        "level": "warning",
        "comment": "bool 值只能为真或假，不具有“大小”等数值意义，bool 值参与位运算、大小比较、数值增减是不合理的。",
        "tag": "expression",
        "standard": "ISO/IEC 14882:2003 5.2.6(1 2),ISO/IEC 14882:2003 5.3.2(1 2),ISO/IEC 14882:2003 D.1-deprecated,ISO/IEC 14882:2011 5.2.6(1 2),ISO/IEC 14882:2011 5.3.2(1 2),ISO/IEC 14882:2011 D.1-deprecated",
        "reference": "CWE-682,CWE-783,CWE-1024,CWE-1025,MISRA C 2004 12.7,MISRA C 2012 10.1,MISRA C++ 2008 5-0-21"
        },
    "ID_inaccessibleTmpObject": {
        "checkPoint": "不应产生无效的临时对象",
        "level": "error",
        "comment": "无名且不受控制的临时对象在构造之后会立即析构，在逻辑上没有意义，往往意味着错误。",
        "tag": "declaration",
        "reference": "CWE-665,C++ Core Guidelines ES.84"
        },
    "ID_qualifierCastedAway": {
        "checkPoint": "类型转换不应去掉 const、volatile 等属性",
        "level": "warning",
        "comment": "去掉 const、volatile 等属性会使相关机制失去意义，往往意味着设计上的缺陷，也会导致标准未定义的行为。",
        "tag": "cast",
        "standard": "ISO/IEC 9899:1999 6.7.3(5)-undefined,ISO/IEC 9899:2011 6.7.3(6)-undefined,ISO/IEC 14882:2003 7.1.5.1(4 7)-undefined,ISO/IEC 14882:2011 7.1.6.1(4 6)-undefined",
        "reference": "C++ Core Guidelines Type.3,MISRA C 2004 11.5,MISRA C 2012 11.8,MISRA C++ 2008 5-2-5,SEI CERT EXP32-C,SEI CERT EXP55-CPP"
        },
    "ID_objectSlicing": {
        "checkPoint": "避免对象切片",
        "level": "warning",
        "comment": "将派生类对象复制为基类对象的行为称为“对象切片”，基类对象不再持有派生类的属性，多态性也不再有效，意味着某种精度上的损失，往往会造成意料之外的错误。",
        "tag": "expression",
        "related": "ID_paramMayBeSlicing",
        "reference": "C++ Core Guidelines ES.63,C++ Core Guidelines C.145,SEI CERT OOP51-CPP"
        },
    "ID_nonPODVariadicArgument": {
        "checkPoint": "不应将非 POD 对象传入可变参数列表",
        "level": "error",
        "comment": "如果将非“POD”对象传入可变参数列表，程序的行为在 C++03 中是未定义的，在 C++11 中是部分由实现定义的。",
        "tag": "expression",
        "related": "ID_badVaArgType",
        "standard": "ISO/IEC 14882:2003 5.2.2(7)-undefined,ISO/IEC 14882:2011 5.2.2(7)-implementation",
        "reference": "CWE-686"
        },
    "ID_downCast": {
        "checkPoint": "避免向下类型转换",
        "level": "suggestion",
        "comment": "从基类到派生类的向下类型转换往往意味着现有接口已经不能满足需求，故应避免这种转换。",
        "tag": "cast",
        "related": "ID_nonDynamicDownCast,ID_narrowCast",
        "reference": "C++ Core Guidelines ES.48"
        },
    "ID_castNoInheritance": {
        "checkPoint": "不应转换无继承关系的指针或引用",
        "level": "warning",
        "comment": "无继承关系的指针或引用之间没有逻辑关系，转换意味着设计缺陷或逻辑错误。",
        "config": [
            "allowWeakerCast: 是否放过与 unsigned char* 的转换"
            ],
        "tag": "cast",
        "related": "ID_stricterAlignedCast,ID_castNonPublicInheritance",
        "standard": "ISO/IEC 9899:1999 6.5(7)-undefined,ISO/IEC 9899:2011 6.5(7)-undefined,ISO/IEC 14882:2003 3.10(15)-undefined,ISO/IEC 14882:2003 4.1(1)-undefined,ISO/IEC 14882:2011 3.10(10)-undefined,ISO/IEC 14882:2011 4.1(1)-undefined",
        "reference": "MISRA C 2012 11.3,MISRA C++ 2008 5-2-7,SEI CERT EXP39-C"
        },
    "ID_castNonPublicInheritance": {
        "checkPoint": "不应转换无 public 继承关系的指针或引用",
        "level": "warning",
        "comment": "public 继承表示派生类是基类的某种扩展，而非 public 继承往往表示派生类是基类的某种例外，基类的方法不再适用于派生类的对象。",
        "tag": "cast",
        "related": "ID_castNoInheritance",
        "standard": "ISO/IEC 14882:2003 4.10(3),ISO/IEC 14882:2011 4.10(3)"
        },
    "ID_redundantCast": {
        "checkPoint": "不应存在多余的类型转换",
        "level": "warning",
        "comment": "多余的类型转换是没有意义的，往往意味着某种错误。",
        "tag": "cast",
        "reference": "CWE-704"
        },
    "ID_functionPointerCast": {
        "checkPoint": "避免转换函数指针",
        "level": "warning",
        "comment": "函数指针和不兼容的类型转换会导致标准未定义的行为。",
        "tag": "cast",
        "standard": "ISO/IEC 9899:1999 6.3.2.3(6 7 8)-undefined,ISO/IEC 9899:1999 6.5.2.2(9)-undefined,ISO/IEC 9899:2011 6.3.2.3(6 7 8)-undefined,ISO/IEC 9899:2011 6.5.2.2(9)-undefined,ISO/IEC 14882:2003 5.2.10(6)-undefined,ISO/IEC 14882:2011 5.2.10(6)-undefined,ISO/IEC 14882:2011 5.2.10(8)-implementation",
        "reference": "MISRA C 2004 11.1,MISRA C 2012 11.1,MISRA C++ 2008 5-2-6"
        },
    "ID_arrayPointerCast": {
        "checkPoint": "避免转换指向数组的指针",
        "level": "warning",
        "comment": "指针的逻辑大小与类型相关，转换指向数组的指针极易造成元素定位、空间计算等方面的错误。",
        "tag": "cast",
        "standard": "ISO/IEC 14882:2003 5.3.5(3)-undefined,ISO/IEC 14882:2011 5.3.5(3)-undefined",
        "reference": "C++ Core Guidelines C.152"
        },
    "ID_nonDynamicDownCast": {
        "checkPoint": "向下动态类型转换应使用 dynamic_cast",
        "level": "warning",
        "comment": "向下动态类型转换应使用 dynamic_cast 以保证安全性。",
        "tag": "cast",
        "standard": "ISO/IEC 14882:2003 5.2.7,ISO/IEC 14882:2003 5.2.9(5 8)-undefined,ISO/IEC 14882:2011 5.2.7,ISO/IEC 14882:2011 5.2.9(11 12)-undefined",
        "related": "ID_downCast",
        "reference": "C++ Core Guidelines Type.2,MISRA C++ 2008 5-2-2"
        },
    "ID_unsuitableReinterpretCast": {
        "checkPoint": "可用其他方式完成的转换不应使用 reinterpret_cast",
        "level": "warning",
        "comment": "reinterpret_cast 将地址强行按另一种类型解释，不考虑转换需要的逻辑，可用 static_cast、dynamic_cast 完成的转换不应使用 reinterpret_cast。",
        "tag": "cast",
        "related": "ID_voidCast",
        "standard": "ISO/IEC 14882:2003 5.2.10(7)-unspecified,ISO/IEC 14882:2011 5.2.10(7)-unspecified",
        "reference": "C++ Core Guidelines Type.1"
        },
    "ID_nonPODBinaryCast": {
        "checkPoint": "非 POD 类的指针与基本类型的指针不应相互转换",
        "level": "warning",
        "comment": "非“POD”对象相关数据之间存在特殊的内在关系，尤其是虚函数表指针、虚基类表指针这种由实现定义的运行时数据，不应当作普通二进制数据处理，非 POD 对象的指针也不应与 void*、unsigned char* 等基本类型的指针相互转换。",
        "tag": "cast",
        "related": "ID_nonPODFilling",
        "reference": "CWE-843"
        },
    "ID_oddNew": {
        "checkPoint": "new 表达式只可用于赋值或当作参数",
        "level": "warning",
        "comment": "new 表达式只应作为“=”的直接右子表达式，或直接作为参数，其他形式均有问题。",
        "tag": "expression",
        "related": "ID_multiAllocation"
        },
    "ID_oddNewCast": {
        "checkPoint": "对 new 表达式不应进行类型转换",
        "level": "warning",
        "comment": "new 表达式本身是类型明确的，转换 new 表达式的类型也容易造成分配、访问或回收相关的错误。",
        "tag": "cast",
        "related": "ID_arrayPointerCast"
        },
    "ID_narrowCast": {
        "checkPoint": "避免类型转换造成数据丢失",
        "level": "warning",
        "comment": "应避免取值范围大的类型向取值范围小的类型隐式转换，相关显式转换也应在合理的条件下完成。",
        "tag": "cast",
        "standard": "ISO/IEC 9899:1999 6.3.1.4(1)-undefined,ISO/IEC 9899:1999 6.3.1.5(2)-undefined,ISO/IEC 9899:2011 6.3.1.4(1)-undefined,ISO/IEC 9899:2011 6.3.1.5(1)-undefined,ISO/IEC 14882:2003 4.8(1)-undefined,ISO/IEC 14882:2003 4.9(1)-undefined,ISO/IEC 14882:2011 4.8(1)-undefined,ISO/IEC 14882:2011 4.9(1 2)-undefined",
        "reference": "C++ Core Guidelines ES.46,MISRA C 2012 10.3,MISRA C 2012 10.5,MISRA C++ 2008 5-0-5,MISRA C++ 2008 5-0-6,SEI CERT FLP34-C"
        },
    "ID_invalidPromotion": {
        "checkPoint": "避免数据丢失造成类型转换失效",
        "level": "warning",
        "comment": "二元算术表达式、以二元算术表达式为分枝的三元表达式不应被隐式或显式地转为取值范围更大的类型。",
        "tag": "cast",
        "related": "ID_evalOverflow",
        "reference": "MISRA C 2012 10.6,MISRA C 2012 10.7,MISRA C 2012 10.8,MISRA C++ 2008 5-0-3,MISRA C++ 2008 5-0-7,MISRA C++ 2008 5-0-8"
        },
    "ID_signChangeCast": {
        "checkPoint": "避免有符号整型与无符号整型相互转换",
        "level": "warning",
        "comment": "有符号整型与无符号整型相互转换易导致意料之外的错误。",
        "tag": "cast",
        "standard": "ISO/IEC 9899:1999 6.3.1.3,ISO/IEC 9899:2011 6.3.1.3",
        "reference": "MISRA C++ 2008 5-0-4,SEI CERT INT02-C"
        },
    "ID_forbidCStyleCast": {
        "checkPoint": "在 C++ 代码中禁用 C 风格类型转换",
        "level": "suggestion",
        "comment": "C 风格类型转换易造成数据丢失或逻辑错误，在 C++ 代码中应使用 static_cast、dynamic_cast 等方法代替 C 风格类型转换。",
        "tag": "cast",
        "reference": "C++ Core Guidelines ES.49,MISRA C++ 2008 5-2-4"
        },
    "ID_missingSideEffect": {
        "checkPoint": "不应存在没有副作用的语句",
        "level": "error",
        "comment": "不能对程序状态产生影响的语句称为无“副作用（side effect）”的语句，往往属于笔误或调试痕迹，应当修正或去除。",
        "tag": "function",
        "standard": "ISO/IEC 9899:1999 5.1.2.3(2),ISO/IEC 9899:2011 5.1.2.3(2),ISO/IEC 14882:2003 1.9(7),ISO/IEC 14882:2011 1.9(12)",
        "reference": "CWE-482,CWE-1164,MISRA C 2004 14.2,MISRA C 2012 2.2,MISRA C++ 2008 0-1-9"
        },
    "ID_returnValueIgnored": {
        "checkPoint": "不应忽略重要的返回值",
        "level": "warning",
        "comment": "与状态判断、信息获取、资源分配有关的返回值不应被忽略。",
        "tag": "expression",
        "config": [
            "allowVoidCastedDiscard: 是否允许通过 void 转换忽略返回值"
            ],
        "standard": "ISO/IEC 14882:2017 10.6.7",
        "reference": "MISRA C 2012 17.7,MISRA C++ 2008 0-1-7"
        },
    "ID_oddPtrCharComparison": {
        "checkPoint": "指针不应与 '\\0' 等字符常量比较大小",
        "level": "warning",
        "comment": "指针与 '\\0'、L'\\0'、u'\\0'、U'\\0' 等字符常量比较大小是非常怪异的，往往是某种笔误。",
        "tag": "pointer",
        "related": "ID_zeroAsPtrValue",
        "reference": "CWE-1025"
        },
    "ID_oddPtrBoolComparison": {
        "checkPoint": "指针不应与 false 比较大小",
        "level": "warning",
        "comment": "指针与 false 比较大小是非常怪异的，往往是某种笔误。",
        "tag": "pointer",
        "related": "ID_zeroAsPtrValue",
        "reference": "CWE-1025"
        },
    "ID_oddPtrZeroComparison": {
        "checkPoint": "指针与空指针不应比较大小",
        "level": "warning",
        "comment": "比较指针与空指针的大小往往意味着逻辑错误。",
        "tag": "pointer",
        "related": "ID_illPtrDiff",
        "standard": "ISO/IEC 9899:1999 6.5.8(5)-undefined,ISO/IEC 9899:2011 6.5.8(5)-undefined",
        "reference": "CWE-1025"
        },
    "ID_selfComparison": {
        "checkPoint": "比较运算符左右子表达式不应相同",
        "level": "warning",
        "comment": "与自身的比较是没意义的，往往是某种笔误。",
        "tag": "expression",
        "reference": "CWE-1025"
        },
    "ID_selfSubtraction": {
        "checkPoint": "减法运算符左右子表达式不应相同",
        "level": "warning",
        "comment": "与自身做减法，结果总为 0，往往是某种笔误。",
        "tag": "expression",
        "reference": "CWE-682"
        },
    "ID_selfDivision": {
        "checkPoint": "除法和求余运算符左右子表达式不应相同",
        "level": "warning",
        "comment": "除法或求余运算符左右子表达式相同，结果总为 1 或 0 以及产生除零异常，往往是某种笔误。",
        "tag": "expression",
        "reference": "CWE-682"
        },
    "ID_selfAssignment": {
        "checkPoint": "赋值运算符左右子表达式不应相同",
        "level": "warning",
        "comment": "赋值运算符左右子表达式相同是没有逻辑意义的，往往是笔误或残留代码。",
        "tag": "expression",
        "reference": "CWE-682"
        },
    "ID_illSelfCompoundAssignment": {
        "checkPoint": "&=、|=、-=、/=、%= 左右子表达式不应相同",
        "level": "warning",
        "comment": "&=、|= 左右子表达式如果相同则没有任何效果，-=、/=、%= 左右子表达式相同则结果总为 1 或 0，这种表达式往往意味着笔误或逻辑错误。",
        "tag": "expression",
        "reference": "CWE-682"
        },
    "ID_selfExclusiveOr": {
        "checkPoint": "异或运算符左右子表达式不应相同",
        "level": "warning",
        "comment": "与自身异或的结果总为 0，而且也可能意味着某种错误。",
        "tag": "expression",
        "reference": "CWE-682"
        },
    "ID_overlappingAssignment": {
        "checkPoint": "不可将对象的值赋给具有部分重叠区域的对象",
        "level": "warning",
        "comment": "如果两个对象的存储区域有部分重叠，将其中一个对象的值赋给另一个对象会导致标准未定义的行为。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.5.16.1(3)-undefined,ISO/IEC 9899:2011 6.5.16.1(3)-undefined,ISO/IEC 14882:2003 5.17(8)-undefined,ISO/IEC 14882:2011 5.17(8)-undefined",
        "reference": "MISRA C 2012 19.1,MISRA C++ 2008 0-2-1"
        },
    "ID_confusingAssignment": {
        "checkPoint": "在表达式中不应多次读写同一对象",
        "level": "warning",
        "comment": "在表达式中多次引用并修改同一对象，很可能会因为非预期的求值顺序而产生错误的结果。",
        "tag": "expression",
        "related": "ID_evaluationOrderReliance",
        "standard": "ISO/IEC 9899:1999 6.5(2)-undefined,ISO/IEC 9899:1999 Annex C,ISO/IEC 9899:2011 6.5(2)-undefined,ISO/IEC 9899:2011 Annex C,ISO/IEC 14882:2003 5(4)-unspecified,ISO/IEC 14882:2011 1.9(15)-undefined,ISO/IEC 14882:2011 5.17(1),ISO/IEC 14882:2017 8.18(1)",
        "reference": "C++ Core Guidelines ES.43,MISRA C 2012 13.2,MISRA C++ 2008 5-0-1,SEI CERT EXP50-CPP"
        },
    "ID_oddPtrCharAssignment": {
        "checkPoint": "不应使用 '\\0' 等字符常量对指针赋值",
        "level": "warning",
        "comment": "用 '\\0'、L'\\0'、u'\\0'、U'\\0' 等字符常量对指针赋值是非常怪异的，往往意味着逻辑错误。",
        "tag": "pointer",
        "related": "ID_zeroAsPtrValue",
        "reference": "CWE-351"
        },
    "ID_oddPtrBoolAssignment": {
        "checkPoint": "不应使用 false 对指针赋值",
        "level": "warning",
        "comment": "用 false 对指针赋值是非常怪异的，会误导维护者，而且也很可能是逻辑错误。",
        "tag": "pointer",
        "related": "ID_zeroAsPtrValue",
        "reference": "CWE-351"
        },
    "ID_oddNullAssignment": {
        "checkPoint": "不应将 NULL 当作整数使用",
        "level": "warning",
        "comment": "标识符 NULL 由实现定义，在 C++ 语言中往往等同于常量 0，但 NULL 只应该用来表示空指针，否则不利于阅读和维护。",
        "tag": "expression",
        "standard": "ISO/IEC 14882:2003 C.2.2.3(1)-implementation,ISO/IEC 14882:2011 C.3.2.4(1)-implementation,ISO/IEC 14882:2017 C.5.2.7(1)-implementation",
        "reference": "MISRA C++ 2008 4-10-1"
        },
    "ID_illFormedCompoundAssignment": {
        "checkPoint": "不应出现复合赋值的错误形式",
        "level": "warning",
        "comment": "如下形式的复合赋值表达式（设 a 和 x 为变量或表达式）：\na -= a - x;\na /= a / x;\na &= a & x;\na |= a | x;\na ^= a ^ x;\n为常见笔误，应将复合赋值改为普通赋值，或去掉重复的子表达式。",
        "tag": "expression",
        "reference": "CWE-682"
        },
    "ID_suspiciousCompoundAssignment": {
        "checkPoint": "避免出现复合赋值的可疑形式",
        "level": "suspicious",
        "comment": "如下形式的复合赋值表达式（设 a 和 x 为变量或表达式）：\na += a + x;\na *= a * x;\na %= a % x;\na <<= a << x;\na >>= a >> x;\n为常见笔误，但在特定需求下也有其逻辑意义，故对这种表达式应给出可疑提醒。",
        "tag": "expression",
        "reference": "CWE-682"
        },
    "ID_redundantCondition": {
        "checkPoint": "不应存在多余的逻辑子表达式",
        "level": "warning",
        "comment": "逻辑或、逻辑与的子表达式有包含关系时，其中的一个表达式是多余的。",
        "tag": "expression",
        "related": "ID_simplifiableCondition,ID_conflictCondition"
        },
    "ID_simplifiableCondition": {
        "checkPoint": "化简可被合并的逻辑子表达式",
        "level": "warning",
        "comment": "逻辑或、逻辑与的子表达式可以合并成一个表达式时应尽量合并。",
        "tag": "expression",
        "related": "ID_redundantCondition,ID_conflictCondition"
        },
    "ID_shortCircuitSideEffect": {
        "checkPoint": "逻辑表达式的右子表达式不应有副作用",
        "level": "suggestion",
        "comment": "逻辑表达式的右子表达式有副作用会使代码变得复杂易错，不利于阅读和维护。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.5.13(4),ISO/IEC 9899:1999 6.5.14(4),ISO/IEC 9899:2011 6.5.13(4),ISO/IEC 9899:2011 6.5.14(4)",
        "reference": "MISRA C 2004 12.4,MISRA C 2012 13.5,MISRA C++ 2008 5-14-1"
        },
    "ID_evaluationOrderReliance": {
        "checkPoint": "避免依赖特定的子表达式求值顺序",
        "level": "warning",
        "comment": "不同的求值顺序不应产生不同的结果，否则极易导致意料之外的错误，也会降低代码的可移植性。",
        "tag": "expression",
        "related": "ID_confusingAssignment",
        "standard": "ISO/IEC 9899:1999 5.1.2.3(2),ISO/IEC 9899:1999 Annex C,ISO/IEC 9899:2011 5.1.2.3(3),ISO/IEC 9899:2011 Annex C",
        "reference": "C++ Core Guidelines ES.43,C++ Core Guidelines ES.44"
        },
    "ID_complexExpression": {
        "checkPoint": "表达式不应过于复杂",
        "level": "suggestion",
        "comment": "复杂的表达式不利于阅读与调试，易包含潜在的错误，应适当拆分。",
        "config": [
            "maxOperatorCount: 运算符最大数量，超过则报出",
            "maxSideEffectPoints: 具有副作用的子表达式最大数量，超过则报出",
            "maxParenthesesLevel: 优先级括号嵌套最大层数，超过则报出",
            "maxPostfixLevel: 函数调用、数组索引嵌套最大层数，超过则报出",
            "maxTernaryLevel: 三元表达式嵌套最大层数，超过则报出"
            ],
        "tag": "expression",
        "reference": "C++ Core Guidelines ES.40"
        },
    "ID_badAssertion": {
        "checkPoint": "断言中的表达式不应恒为真",
        "level": "error",
        "comment": "恒为真的断言是没有意义的。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 7.2,ISO/IEC 9899:2011 7.2"
        },
    "ID_sideEffectAssertion": {
        "checkPoint": "断言中的表达式不应有副作用",
        "level": "error",
        "comment": "断言中的表达式如果有副作用，不能保证在所有编译设置下都有效。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 7.2,ISO/IEC 9899:2011 7.2",
        "related": "ID_macro_sideEffectArgs,ID_unevaluatedSideEffect",
        "reference": "SEI CERT PRE31-C"
        },
    "ID_complexAssertion": {
        "checkPoint": "断言中的表达式不应过于复杂",
        "level": "suggestion",
        "comment": "断言中的表达式不应过于复杂，否则不易定位具体是哪一项不符合断言，不利于调试。",
        "config": [
            "maxLogicOperatorCount: 断言表达式中“逻辑与”运算符的最大数量，超过则报出"
            ],
        "tag": "expression"
        },
    "ID_explicitDtorCall": {
        "checkPoint": "避免显式调用析构函数",
        "level": "suggestion",
        "comment": "显式调用析构函数会提前结束对象的生命周期，之后对该对象的任何访问都会导致标准未定义的行为。",
        "tag": "expression",
        "standard": "ISO/IEC 14882:2003 12.4(14)-undefined,ISO/IEC 14882:2011 12.4(15)-undefined",
        "related": "ID_missingResetNull"
        },
    "ID_fixedAddrToPointer": {
        "checkPoint": "不应将非零常量值赋值给指针",
        "level": "warning",
        "comment": "固定地址是不可移植的，且存在安全隐患。",
        "config": [
            "allowMinusOneAsPointerValue: 是否允许 -1 作为指针的值"
            ],
        "tag": "pointer",
        "related": "ID_addressExposure,ID_plainSensitiveInfo,ID_ptrIntCast",
        "reference": "CWE-587"
        },
    "ID_unnecessaryAllocation": {
        "checkPoint": "避免不必要的内存分配",
        "level": "warning",
        "comment": "对单独的基本变量或只包含少量基本变量的对象不应使用动态内存分配。",
        "tag": "resource",
        "related": "ID_dynamicAllocation"
        },
    "ID_variableLengthArray": {
        "checkPoint": "避免使用变长数组",
        "level": "warning",
        "comment": "使用变长数组（variable length array）可以在栈上动态分配内存，但分配失败时的行为不受程序控制。",
        "tag": "resource",
        "related": "ID_stackAllocation",
        "standard": "ISO/IEC 9899:1999 6.7.5.2(5),ISO/IEC 9899:2011 6.7.6.2(5)",
        "reference": "MISRA C 2012 18.8"
        },
    "ID_stackAllocation": {
        "checkPoint": "避免使用在栈上分配内存的函数",
        "level": "warning",
        "comment": "alloca、strdupa 等函数可以在栈上动态分配内存，但分配失败时的行为不受程序控制。",
        "tag": "resource",
        "related": "ID_variableLengthArray,ID_invalidNullCheck",
        "reference": "CWE-770,SEI CERT MEM05-C"
        },
    "ID_unsuitableArraySize": {
        "checkPoint": "局部数组不应过大",
        "level": "warning",
        "comment": "局部数组在栈上分配空间，如果占用空间过大会导致栈溢出错误。",
        "config": [
            "maxLocalArraySize: 函数内局部数组空间之和的上限，超过则报出"
            ],
        "tag": "resource",
        "reference": "CWE-770,SEI CERT MEM05-C"
        },
    "ID_forbidMallocAndFree": {
        "checkPoint": "C++ 代码中禁用 C 内存管理函数",
        "level": "warning",
        "comment": "在 C++ 代码中不应使用 malloc、free 等 C 内存管理函数，应使用 C++ 内存管理方法。",
        "tag": "resource",
        "related": "ID_ownerlessResource",
        "reference": "C++ Core Guidelines R.10"
    },
    "ID_ownerlessResource": {
        "checkPoint": "资源应接受对象化管理",
        "level": "warning",
        "comment": "使资源接受对象化管理，免去繁琐易错的手工分配回收过程，是 C++ 程序设计的重要方法。",
        "tag": "resource",
        "reference": "C++ Core Guidelines R.11,C++ Core Guidelines R.12"
        },
    "ID_dynamicAllocation": {
        "checkPoint": "避免动态内存分配",
        "level": "warning",
        "comment": "标准库提供的动态内存分配方法，其策略和算法不在使用者的控制之内，很多细节是标准没有明确规定的，而且也是内存耗尽等问题的根源，有高可靠性要求的嵌入式系统应选取本规则。",
        "tag": "resource",
        "standard": "ISO/IEC 9899:1999 7.20.3,ISO/IEC 9899:2011 7.22.3",
        "reference": "C++ Core Guidelines R.5,MISRA C 2004 20.4,MISRA C 2012 21.3,MISRA C++ 2008 18-4-1"
        },
    "ID_unsuitableMove": {
        "checkPoint": "合理使用 std::move",
        "level": "warning",
        "comment": "std::move 的参数应为左值，返回值应直接作为接口的参数，除此之外的应用价值有限，且易产生错误。",
        "tag": "expression",
        "standard": "ISO/IEC 14882:2011 20.2.3(6),ISO/IEC 14882:2017 23.2.5(5)",
        "reference": "C++ Core Guidelines ES.56,C++ Core Guidelines F.18,C++ Core Guidelines F.48"
        },
    "ID_useAfterMove": {
        "checkPoint": "对象被移动后应重置状态再使用",
        "level": "warning",
        "comment": "对象被移动后在逻辑上不再有效，如果没有通过清空数据或重新初始化等方法更新对象的状态，不应再使用该对象。",
        "tag": "resource",
        "related": "ID_unsuitableMove",
        "standard": "ISO/IEC 14882:2011 17.6.5.15(1)-unspecified,ISO/IEC 14882:2017 20.5.5.15(1)-unspecified",
        "reference": "C++ Core Guidelines ES.56,SEI CERT EXP63-CPP"
        },
    "ID_unsuitableForward": {
        "checkPoint": "合理使用 std::forward",
        "level": "warning",
        "comment": "std::forward 的参数应为“转发引用（forwarding references）”，返回值应直接作为接口的参数，除此之外的使用方式价值有限，且易产生错误。",
        "tag": "expression",
        "related": "ID_illForwardingReference",
        "standard": "ISO/IEC 14882:2011 20.2.3(1),ISO/IEC 14882:2017 23.2.5(1)",
        "reference": "C++ Core Guidelines F.19"
        },
    "ID_illForwardingReference": {
        "checkPoint": "转发引用只应作为 std::forward 的参数",
        "level": "warning",
        "comment": "不应混淆“转发引用（forwarding references）”与右值引用，除作为 std::forward 的参数之外，不应对转发引用再有任何操作。",
        "tag": "function",
        "related": "ID_unsuitableForward",
        "standard": "ISO/IEC 14882:2011 20.2.3(1),ISO/IEC 14882:2017 23.2.5(1)",
        "reference": "C++ Core Guidelines F.19"
        },
    "ID_multiAllocation": {
        "checkPoint": "在一个表达式语句中最多使用一次 new",
        "level": "warning",
        "comment": "如果表达式语句多次使用 new，一旦某个构造函数抛出异常就会造成内存泄漏。",
        "tag": "resource",
        "related": "ID_memoryLeak",
        "reference": "C++ Core Guidelines R.13"
        },
    "ID_recursion": {
        "checkPoint": "避免函数调用自身",
        "level": "warning",
        "comment": "函数直接或间接调用自身可实现递归算法，但调用栈的消耗情况不够直观，易导致栈溢出等错误。",
        "tag": "function",
        "reference": "MISRA C 2012 17.2,MISRA C++ 2008 7-5-4"
        },
    "ID_disorderedInitialization": {
        "checkPoint": "成员初始化应遵循声明的顺序",
        "level": "error",
        "comment": "类成员的初始化顺序是按声明的顺序进行的，初始化前面的成员时不可使用后面成员的值。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2003 12.6.2(5),ISO/IEC 14882:2011 12.6.2(10)",
        "reference": "C++ Core Guidelines C.47"
        },
    "ID_memberInitialization": {
        "checkPoint": "成员须在声明处或构造时初始化",
        "level": "warning",
        "comment": "成员的声明和使用相距较远，更容易造成未初始化先使用的问题，所以应在声明处或构造函数中初始化所有成员。",
        "tag": "function",
        "reference": "CWE-908,C++ Core Guidelines C.41"
        },
    "ID_invalidWrite": {
        "checkPoint": "不应存在无效的写入操作",
        "level": "warning",
        "comment": "对于内存中的数据，写入之后应被读取，否则没有意义。",
        "tag": "function"
        },
    "ID_memberDeallocation": {
        "checkPoint": "对象申请的资源应在析构函数中释放",
        "level": "warning",
        "comment": "对象在析构函数中释放自己申请的资源是 C++ 程序设计的重要原则，不可被遗忘，也不应要求用户释放。",
        "tag": "resource",
        "related": "ID_memoryLeak,ID_resourceLeak",
        "reference": "C++ Core Guidelines C.31,C++ Core Guidelines E.6"
        },
    "ID_virtualCallInConstructor": {
        "checkPoint": "在构造函数中不应使用动态类型",
        "level": "warning",
        "comment": "对象的动态类型在其构造过程中不生效。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2003 10.4(6)-undefined,ISO/IEC 14882:2011 10.4(6)-undefined",
        "reference": "C++ Core Guidelines C.82,MISRA C++ 2008 12-1-1,Effective C++ item 9"
        },
    "ID_virtualCallInDestructor": {
        "checkPoint": "在析构函数中不应使用动态类型",
        "level": "warning",
        "comment": "对象的动态类型在其析构过程中不生效。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2003 10.4(6)-undefined,ISO/IEC 14882:2011 10.4(6)-undefined",
        "reference": "C++ Core Guidelines C.82,MISRA C++ 2008 12-1-1,Effective C++ item 9"
        },
    "ID_exitCallInDestructor": {
        "checkPoint": "在析构函数中避免调用 exit 函数",
        "level": "warning",
        "comment": "程序调用 exit 后，具有静态或线程存储期的对象开始析构，如果这种对象的析构函数再调用 exit 会导致标准未定义的行为，为规避意料之外的错误，应统一要求在析构函数中避免直接或间接地调用 exit。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2003 3.6.1(4)-undefined,ISO/IEC 14882:2011 3.6.1(4)-undefined"
        },
    "ID_sideEffectCopyConstructor": {
        "checkPoint": "拷贝构造函数应避免实现复制之外的功能",
        "level": "warning",
        "comment": "拷贝构造函数的执行在某些情况下可被省略，其执行次数可能与预期不符，复制之外的功能也可能无法生效。",
        "tag": "function",
        "related": "ID_sideEffectMoveConstructor",
        "standard": "ISO/IEC 14882:2003 12.8(15)-implementation,ISO/IEC 14882:2011 12.8(31)-implementation,ISO/IEC 14882:2017 15.8.3(1)-implementation",
        "reference": "MISRA C++ 2008 12-8-1"
        },
    "ID_sideEffectMoveConstructor": {
        "checkPoint": "移动构造函数应避免实现数据移动之外的功能",
        "level": "warning",
        "comment": "移动构造函数的执行在某些情况下可被省略，其执行次数可能与预期不符，数据移动之外的功能也可能无法生效。",
        "tag": "function",
        "related": "ID_sideEffectCopyConstructor",
        "standard": "ISO/IEC 14882:2011 12.8(31)-implementation,ISO/IEC 14882:2017 15.8.3(1)-implementation"
        },
    "ID_throwInConstructor": {
        "checkPoint": "构造函数抛出异常需避免相关资源泄漏",
        "level": "warning",
        "comment": "构造函数抛出异常表示对象构造失败，不会再执行相关析构函数，需要保证已分配的资源被有效回收。",
        "tag": "resource",
        "related": "ID_ownerlessResource,ID_multiAllocation,ID_memoryLeak",
        "standard": "ISO/IEC 14882:2003 5.3.4(17),ISO/IEC 14882:2011 5.3.4(18),ISO/IEC 14882:2017 8.3.4(21)"
        },
    "ID_throwInDestructor": {
        "checkPoint": "析构函数不可抛出异常",
        "level": "error",
        "comment": "析构函数抛出异常会违反异常处理机制。",
        "tag": "exception",
        "related": "ID_throwInDelete,ID_throwInHash,ID_throwInSwap,ID_throwInMove",
        "standard": "ISO/IEC 14882:2003 15.2(3),ISO/IEC 14882:2011 3.7.4.2(3)-undefined,ISO/IEC 14882:2011 15.2(3)",
        "reference": "C++ Core Guidelines C.36,C++ Core Guidelines C.37,MISRA C++ 2008 15-5-1,SEI CERT DCL57-CPP"
        },
    "ID_throwInDelete": {
        "checkPoint": "内存回收函数不可抛出异常",
        "level": "error",
        "comment": "内存回收函数抛出异常会导致标准未定义的行为。",
        "tag": "exception",
        "related": "ID_throwInDestructor,ID_throwInHash,ID_throwInSwap,ID_throwInMove",
        "standard": "ISO/IEC 14882:2003 15.2(3),ISO/IEC 14882:2011 3.7.4.2(3)-undefined,ISO/IEC 14882:2011 15.2(3)",
        "reference": "C++ Core Guidelines E.16"
        },
    "ID_throwInHash": {
        "checkPoint": "与标准库相关的 hash 过程不应抛出异常",
        "level": "suggestion",
        "comment": "对象的 hash 过程中不应抛出异常，否则相关的容器和算法无法正常工作。",
        "tag": "exception",
        "reference": "C++ Core Guidelines C.89"
        },
    "ID_throwInSwap": {
        "checkPoint": "对象交换过程不可抛出异常",
        "level": "warning",
        "comment": "两个对象在交换（swap）过程中，每个对象的状态都是不完整的，如果在交换中途抛出异常，对象将处于错误的状态。",
        "tag": "exception",
        "related": "ID_exceptionUnsafe,ID_throwInMove",
        "reference": "C++ Core Guidelines C.84,C++ Core Guidelines C.85"
        },
    "ID_throwInMove": {
        "checkPoint": "移动构造函数和移动赋值运算符不可抛出异常",
        "level": "warning",
        "comment": "在移动过程中，对象的状态是不完整的，如果在中途抛出异常，对象将处于错误的状态。",
        "tag": "exception",
        "related": "ID_throwInSwap",
        "reference": "C++ Core Guidelines C.66"
        },
    "ID_throwInNoexcept": {
        "checkPoint": "由 noexcept 标记的函数不可产生未处理的异常",
        "level": "warning",
        "comment": "由 noexcept 标记的函数产生未被处理的异常属于逻辑错误，会引发 std::terminate 函数的执行，使程序异常终止。",
        "tag": "exception",
        "related": "ID_uncaughtException",
        "standard": "ISO/IEC 14882:2011 15.4(9),ISO/IEC 14882:2017 18.4(5)",
        "reference": "SEI CERT ERR55-CPP"
        },
    "ID_localAddressFlowOut": {
        "checkPoint": "不可返回局部对象的地址或引用",
        "level": "error",
        "comment": "局部对象的生命周期结束后，其地址或引用也会失效，如果继续访问会导致标准未定义的行为。",
        "tag": "function",
        "related": "ID_tmpAddressFlowOut,ID_danglingDeref,ID_illLifetime",
        "standard": "ISO/IEC 9899:1999 6.2.4(2)-undefined,ISO/IEC 9899:2011 6.2.4(2)-undefined",
        "reference": "CWE-562,C++ Core Guidelines F.43,MISRA C 2012 18.6,MISRA C++ 2008 7-5-1,MISRA C++ 2008 7-5-2"
        },
    "ID_tmpAddressFlowOut": {
        "checkPoint": "不可返回临时对象的地址或引用",
        "level": "error",
        "comment": "临时对象可以通过常量引用或右值引用等方式作为函数的参数，但生命周期结束后，其地址或引用就会失效，如果继续访问会导致标准未定义的行为，对引用型参数取地址应谨慎。",
        "tag": "function",
        "related": "ID_localAddressFlowOut,ID_danglingDeref,ID_illLifetime",
        "standard": "ISO/IEC 9899:1999 6.2.4(2)-undefined,ISO/IEC 9899:2011 6.2.4(2)-undefined",
        "reference": "MISRA C++ 2008 7-5-3"
        },
    "ID_unreachableCode": {
        "checkPoint": "不应存在得不到执行机会的代码",
        "level": "error",
        "comment": "得不到执行机会的代码是没有意义的，往往意味着逻辑错误。",
        "tag": "function",
        "related": "ID_staticNotUsed,ID_privateNotUsed,ID_constLogicExpression,ID_invalidCondition,ID_switch_caseOutOfRange,ID_if_identicalCondition,ID_if_hiddenCondition,ID_try_disorderedEllipsis,ID_try_disorderedHandlers,ID_uncondJump",
        "reference": "CWE-561,MISRA C 2004 14.1,MISRA C 2012 2.1,MISRA C++ 2008 0-1-1"
        },
    "ID_localInitialization": {
        "checkPoint": "局部对象在使用前应被初始化",
        "level": "error",
        "comment": "未初始化的局部对象具有不确定的值，读取未初始化的对象会导致标准未定义的行为。",
        "tag": "function",
        "related": "ID_illAccess",
        "standard": "ISO/IEC 9899:1999 6.2.4(5 6),ISO/IEC 9899:2011 6.2.4(6 7),ISO/IEC 9899:2011 6.3.2.1(2)-undefined,ISO/IEC 14882:2003 4.1(1)-undefined,ISO/IEC 14882:2003 8.5(9),ISO/IEC 14882:2011 4.1(1)-undefined,ISO/IEC 14882:2011 8.5(11)",
        "reference": "CWE-457,C++ Core Guidelines ES.20,MISRA C 2004 9.1,MISRA C 2012 9.1,MISRA C++ 2008 8-5-1"
        },
    "ID_notAllBranchReturn": {
        "checkPoint": "有返回值的函数其所有分枝都应显式返回",
        "level": "error",
        "comment": "如果有返回值的函数在某个分枝没有使用 return 语句显式返回，会导致标准未定义的行为。",
        "tag": "function",
        "standard": "ISO/IEC 9899:1999 5.1.2.2.3(1),ISO/IEC 9899:1999 6.9.1(12)-undefined,ISO/IEC 9899:2011 5.1.2.2.3(1),ISO/IEC 9899:2011 6.9.1(12)-undefined,ISO/IEC 14882:2003 3.6.1(5),ISO/IEC 14882:2003 6.6.3(2)-undefined,ISO/IEC 14882:2011 3.6.1(5),ISO/IEC 14882:2011 6.6.3(2)-undefined",
        "reference": "CWE-394,MISRA C 2004 16.8,MISRA C 2012 17.4,MISRA C++ 2008 8-4-3"
        },
    "ID_returnSameConst": {
        "checkPoint": "被返回的表达式不应为相同的常量",
        "level": "warning",
        "comment": "函数所有返回值均为相同的常量是没有意义的。",
        "tag": "function"
        },
    "ID_returnOdd": {
        "checkPoint": "被返回的表达式应与函数的返回类型一致",
        "level": "warning",
        "comment": "为了提高可读性并规避意料之外的错误，应避免隐式转换被返回的表达式。",
        "tag": "function",
        "reference": "MISRA C++ 2008 4-10-1"
        },
    "ID_uncondJump": {
        "checkPoint": "不应存在不受条件控制的跳转语句",
        "level": "warning",
        "comment": "不受条件控制的跳转语句会剥夺其后续代码的执行机会，往往意味着逻辑错误，也可能是调试或维护痕迹。",
        "tag": "control",
        "related": "ID_unreachableCode"
        },
    "ID_redundantJump": {
        "checkPoint": "不应存在不改变程序流程的跳转语句",
        "level": "warning",
        "comment": "不改变程序流程的跳转语句是多余的，往往意味着逻辑错误，也可能是调试或维护痕迹。",
        "tag": "control"
        },
    "ID_paramPassedByValue": {
        "checkPoint": "非基本类型的常量参数不应按值传递",
        "level": "warning",
        "comment": "常量参数不可被改变，按值传递产生的复制开销是没有意义的，应使用常量引用传递参数。",
        "tag": "function",
        "reference": "C++ Core Guidelines F.16"
        },
    "ID_paramMayBeSlicing": {
        "checkPoint": "多态类的对象作为参数时不应采用值传递的方式",
        "level": "warning",
        "comment": "将派生类对象通过传值的方式转换为基类对象后，不再遵循多态机制，易产生意料之外的错误，应采用指针或引用的方式传递多态类对象。",
        "tag": "function",
        "related": "ID_objectSlicing",
        "reference": "C++ Core Guidelines C.145,C++ Core Guidelines ES.63"
        },
    "ID_relyOnExternalObject": {
        "checkPoint": "全局对象的初始化不可依赖未初始化的对象",
        "level": "warning",
        "comment": "全局对象的初始化或构造过程不可依赖在其他源文件中定义的全局对象，也不可依赖在其后面定义的对象。",
        "tag": "global",
        "standard": "ISO/IEC 9899:2011 5.1.2(1)-unspecified,ISO/IEC 14882:2011 3.6.2(2), ISO/IEC 14882:2011 3.6.2(3)-unspecified,ISO/IEC 14882:2017 6.6.2(3)-unspecified,ISO/IEC 14882:2017 6.6.3(2)",
        "reference": "C++ Core Guidelines I.22"
        },
    "ID_abusedAuto": {
        "checkPoint": "合理使用 auto 关键字",
        "level": "suggestion",
        "comment": "auto 关键字隐藏了类型名称，在使用时需注意不应降低可读性。",
        "tag": "declaration",
        "related": "ID_roughAuto",
        "reference": "C++ Core Guidelines ES.11"
        },
    "ID_roughAuto": {
        "checkPoint": "用 auto 声明指针或引用时应显式标明 *、& 等符号",
        "level": "suggestion",
        "comment": "用 auto 声明指针时显式标明 * 号有利于提高可读性，否则会使人误以为是某种非指针的对象。在声明引用时必须显式标明 & 或 && 号，否则成为对象声明，导致逻辑错误或造成不必要的复制开销。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2011 7.1.6.4,ISO/IEC 14882:2017 10.1.7.4"
        },
    "ID_selfDependentInitialization": {
        "checkPoint": "对象初始化不可依赖自身的值",
        "level": "error",
        "comment": "对象初始化依赖自身的值属于逻辑错误，也是常见的笔误。",
        "tag": "declaration"
        },
    "ID_invalidLocalDeclaration": {
        "checkPoint": "不应存在没有被用到的局部声明",
        "level": "warning",
        "comment": "没有被用到的局部声明是没有意义的，往往意味着代码冗余或功能不完整，也可能导致严重的逻辑错误。",
        "tag": "declaration",
        "reference": "MISRA C++ 2008 0-1-3"
        },
    "ID_tooManyParams": {
        "checkPoint": "函数参数的数量应在规定范围之内",
        "level": "warning",
        "comment": "函数参数的数量应在规定范围之内。",
        "config": [
            "maxParamCount: 函数参数数量上限，超过则报出",
            "maxInnerFunParamCount: static 函数或 private 成员函数参数数量上限，超过则报出"
            ],
        "tag": "function",
        "reference": "C++ Core Guidelines F.2,C++ Core Guidelines I.23"
        },
    "ID_paramNotUsed": {
        "checkPoint": "不应存在未被使用的具名形式参数",
        "level": "suggestion",
        "comment": "如果函数的某个参数在函数内没有被用到，意味着函数的功能与设计之间存在差距。",
        "tag": "function",
        "reference": "C++ Core Guidelines F.9,MISRA C 2012 2.7,MISRA C++ 2008 0-1-11"
        },
    "ID_inconsistentParamName": {
        "checkPoint": "函数的参数名称在声明处和实现处应保持一致",
        "level": "warning",
        "comment": "参数名称在声明处和实现处不一致会误导函数的使用者，而且很可能是实现错误。",
        "tag": "function",
        "related": "ID_inconsistentDeclaration",
        "reference": "MISRA C++ 2008 8-4-2"
        },
    "ID_definedInHeader": {
        "checkPoint": "在头文件中不应实现函数或定义对象",
        "level": "warning",
        "comment": "头文件中的函数或对象会被引入不同的翻译单元（translate-unit）造成编译冲突。",
        "tag": "function",
        "reference": "C++ Core Guidelines SF.2"
        },
    "ID_complexInlineFunction": {
        "checkPoint": "不应定义过于复杂的内联函数",
        "level": "suggestion",
        "comment": "是否对函数进行内联优化由实现定义，当函数执行的开销远大于调用的开销时，将函数定义为内联函数是没有意义的。",
        "config": [
            "maxInlineStatementsCount: 内联函数语句数量上限，超过则报出"
            ],
        "tag": "function",
        "standard": "ISO/IEC 9899:1999 6.7.4(5)-implementation,ISO/IEC 9899:2011 6.7.4(6)-implementation,ISO/IEC 14882:2003 7.1.2(2)-implementation,ISO/IEC 14882:2011 7.1.2(2)-implementation",
        "reference": "C++ Core Guidelines F.5"
        },
    "ID_nonVirtualOverride": {
        "checkPoint": "派生类不应重新定义与基类相同的非虚函数",
        "level": "warning",
        "comment": "派生类不应重新定义与基类相同的非虚函数，否则与多态机制相矛盾，易造成意料之外的问题。",
        "tag": "declaration",
        "reference": "Effective C++ item 36"
        },
    "ID_unsuitableReturn": {
        "checkPoint": "具有 noreturn 属性的函数不应返回",
        "level": "warning",
        "comment": "具有 noreturn 属性的函数返回会导致标准未定义的行为。",
        "tag": "function",
        "related": "ID_unsuitableReturnType",
        "standard": "ISO/IEC 9899:2011 6.7.4(8 12)-undefined,ISO/IEC 14882:2011 7.6.3(2)-undefined"
        },
    "ID_unsuitableReturnType": {
        "checkPoint": "具有 noreturn 属性的函数返回类型只应为 void",
        "level": "warning",
        "comment": "返回类型不是 void 说明函数有返回值，与 noreturn 属性矛盾。",
        "tag": "function",
        "related": "ID_unsuitableReturn",
        "standard": "ISO/IEC 9899:2011 6.7.4(8 12)-undefined,ISO/IEC 14882:2011 7.6.3(2)-undefined"
        },
    "ID_overloadLogicOperator": {
        "checkPoint": "不应重载“逻辑与”和“逻辑或”运算符",
        "level": "suggestion",
        "comment": "对“逻辑与”、“逻辑或”等运算符的重载会影响效率，甚至造成不符合预期的结果。",
        "tag": "declaration",
        "related": "ID_overloadComma",
        "standard": "ISO/IEC 14882:2003 5.2.2(8)-unspecified,ISO/IEC 14882:2011 5.2.2(8)",
        "reference": "MISRA C++ 2008 5-2-11"
        },
    "ID_overloadComma": {
        "checkPoint": "不应重载逗号运算符",
        "level": "suggestion",
        "comment": "逗号表达式意在从左至右依次执行各子表达式，但重载逗号运算符会打破这一规则，易造成意料之外的结果。",
        "tag": "declaration",
        "related": "ID_overloadLogicOperator",
        "standard": "ISO/IEC 14882:2003 5.2.2(8)-unspecified,ISO/IEC 14882:2011 5.2.2(8)",
        "reference": "MISRA C++ 2008 5-2-11"
        },
    "ID_overloadAddressOperator": {
        "checkPoint": "不应重载取地址运算符",
        "level": "suggestion",
        "comment": "取地址运算符（一元 & 运算符），重载之后可以返回任意地址，极易误用。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2003 5.3.1(4)-undefined,ISO/IEC 14882:2011 5.3.1(5)-undefined",
        "reference": "C++ Core Guidelines C.166,MISRA C++ 2008 5-3-3"
        },
    "ID_missingVirtualDestructor": {
        "checkPoint": "有虚函数的基类应具有虚析构函数",
        "level": "warning",
        "comment": "为了避免意料之外的资源泄漏，有虚函数的基类都应该具有虚析构函数。",
        "tag": "type",
        "standard": "ISO/IEC 14882:2003 5.3.5(3)-undefined,ISO/IEC 14882:2003 12.4(7),ISO/IEC 14882:2011 5.3.5(3)-undefined,ISO/IEC 14882:2011 12.4(9)",
        "reference": "CWE-1045,CWE-1079,CWE-1087,C++ Core Guidelines C.35,C++ Core Guidelines C.127"
        },
    "ID_diamondInheritance": {
        "checkPoint": "避免多重继承自同一非虚基类",
        "level": "warning",
        "comment": "当派生类有多个基类，这些基类又派生自同一非虚基类时，派生类对象会持有该非虚基类的多个实例，造成逻辑和存储上的冗余。",
        "tag": "type",
        "related": "ID_diamondExceptionInheritance",
        "standard": "ISO/IEC 14882:2003 5.2.9(5 8)-undefined,ISO/IEC 14882:2003 10.1(4 5 6),ISO/IEC 14882:2011 5.2.9(11 12)-undefined,ISO/IEC 14882:2011 10.1(4 5 6 7)",
        "reference": "C++ Core Guidelines C.137"
        },
    "ID_diamondExceptionInheritance": {
        "checkPoint": "避免异常类多重继承自同一非虚基类",
        "level": "warning",
        "comment": "当异常类有多个基类，这些基类又派生自同一非虚基类时，无法通过该非虚基类捕获异常。",
        "tag": "exception",
        "related": "ID_diamondInheritance",
        "standard": "ISO/IEC 14882:2003 10.1(4 5 6),ISO/IEC 14882:2011 10.1(4 5 6 7)"
        },
    "ID_roughTemplateConstructor": {
        "checkPoint": "带模板的构造函数不应与拷贝或移动构造函数混淆",
        "level": "warning",
        "comment": "带模板的构造函数不应与拷贝或移动构造函数混淆，存在带模板的构造函数时应明确声明拷贝和移动构造函数。",
        "tag": "type",
        "related": "ID_roughTemplateAssignOperator",
        "standard": "ISO/IEC 14882:2003 12.8(2),ISO/IEC 14882:2011 12.8(2),ISO/IEC 14882:2011 12.8(3)",
        "reference": "MISRA C++ 2008 14-5-2"
        },
    "ID_roughTemplateAssignOperator": {
        "checkPoint": "带模板的赋值运算符不应与拷贝或移动赋值运算符混淆",
        "level": "warning",
        "comment": "带模板的赋值运算符不应与拷贝或移动赋值运算符混淆，存在带模板的赋值运算符时应明确声明拷贝和移动赋值运算符。",
        "tag": "type",
        "related": "ID_roughTemplateConstructor",
        "standard": "ISO/IEC 14882:2003 12.8(9),ISO/IEC 14882:2011 12.8(17),ISO/IEC 14882:2011 12.8(19)",
        "reference": "MISRA C++ 2008 14-5-3"
        },
    "ID_missingExplicitOverride": {
        "checkPoint": "重写的虚函数应声明为 override 或 final",
        "level": "suggestion",
        "comment": "将重写的虚函数都声明为 override 或 final 有利于提高可读性，并可确保虚函数被有效重写。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2011 10.3(4 5),ISO/IEC 14882:2017 13.3(4 5)",
        "reference": "C++ Core Guidelines C.128"
        },
    "ID_incompleteNewDeletePair": {
        "checkPoint": "资源的分配与回收方法应成对提供",
        "level": "suggestion",
        "comment": "资源的分配和回收方法应在同一库或主程序等可执行模块、类等逻辑模块中提供。",
        "tag": "resource",
        "related": "ID_memberDeallocation,ID_crossModuleTransfer,ID_incompatibleDealloc",
        "reference": "C++ Core Guidelines R.15"
        },
    "ID_crossModuleTransfer": {
        "checkPoint": "不应在模块之间传递容器类对象",
        "level": "warning",
        "comment": "在库或主程序等可执行模块之间传递容器类对象会造成分配回收方面的冲突。",
        "tag": "resource",
        "related": "ID_incompleteNewDeletePair,ID_ABIConflict"
        },
    "ID_ABIConflict": {
        "checkPoint": "不应在模块之间传递非标准布局类型的对象",
        "level": "warning",
        "comment": "非标准布局类型的运行时特性依赖编译器的具体实现，在不同编译器生成的模块间传递这种类型的对象会导致运行时错误。",
        "tag": "resource",
        "standard": "ISO/IEC 14882:2011 9(7),ISO/IEC 14882:2017 12(7)",
        "reference": "SEI CERT EXP60-CPP"
        },
    "ID_crossModuleException": {
        "checkPoint": "不应在模块之间传播异常",
        "level": "warning",
        "comment": "异常的传播机制依赖编译器的具体实现，在不同编译器产生的模块间传播异常会造成运行时错误。",
        "tag": "exception",
        "related": "ID_ABIConflict",
        "reference": "SEI CERT ERR59-CPP"
        },
    "ID_stdNamespaceModified": {
        "checkPoint": "不可修改 std 命名空间",
        "level": "warning",
        "comment": "可以为用户定义的类型特化某些标准模板类，除此之外对 std 命名空间添加、修改甚至删除任何代码所导致的后果都是标准未定义的。",
        "tag": "global",
        "standard": "ISO/IEC 14882:2011 17.6.4.2.1(1 2)-undefined,ISO/IEC 14882:2017 20.5.4.2.1(1 2)-undefined",
        "reference": "SEI CERT DCL58-CPP"
        },
    "ID_usingSelf": {
        "checkPoint": "避免无效的 using directive",
        "level": "warning",
        "comment": "用 using directive 引用当前命名空间属于无效代码，可能意味着某种错误。",
        "tag": "global"
        },
    "ID_anonymousNamespaceInHeader": {
        "checkPoint": "头文件中不应定义匿名命名空间",
        "level": "warning",
        "comment": "在头文件中定义匿名命名空间相当于在头文件中定义静态数据，头文件被多个源文件包含时会造成数据冗余。",
        "tag": "global",
        "related": "ID_staticInHeader,ID_unsuitableDeclaration",
        "standard": "ISO/IEC 14882:2003 7.3.1.1,ISO/IEC 14882:2011 7.3.1.1",
        "reference": "C++ Core Guidelines SF.21,MISRA C++ 2008 7-3-3"
        },
    "ID_topInlineNamespace": {
        "checkPoint": "不应定义全局 inline 命名空间",
        "level": "suggestion",
        "comment": "定义全局 inline 命名空间相当于没有命名空间，应在普通命名空间之内使用 inline 命令空间。",
        "tag": "global"
        },
    "ID_usingNamespaceInHeader": {
        "checkPoint": "头文件中不应使用 using directive",
        "level": "warning",
        "comment": "在头文件的全局作用域中使用 using directive 极易造成命名冲突，且影响范围难以控制。",
        "tag": "global",
        "related": "ID_forbidUsingDirectives",
        "reference": "C++ Core Guidelines SF.7,MISRA C++ 2008 7-3-6"
        },
    "ID_forbidUsingDirectives": {
        "checkPoint": "全局及命名空间作用域中禁用 using directive",
        "level": "suggestion",
        "comment": "通过 using directive 将其他命名空间中的名称一并引入当前命名空间，是对命名空间机制的破坏，会造成难以预料的冲突与混乱。",
        "tag": "global",
        "related": "ID_usingNamespaceInHeader",
        "reference": "C++ Core Guidelines SF.6,MISRA C++ 2008 7-3-4"
        },
    "ID_staticInAnonymousNamespace": {
        "checkPoint": "匿名命名空间中不应使用静态声明",
        "level": "warning",
        "comment": "匿名命名空间中的元素已具有内部链接性（internal linkage），不应再用 static 关键字限定。",
        "tag": "global",
        "standard": "ISO/IEC 14882:2011 3.5(4),ISO/IEC 14882:2017 6.5(4)"
        },
    "ID_staticAndConst": {
        "checkPoint": "全局对象不应同时被 static 和 const 等关键字限定",
        "level": "warning",
        "comment": "在 C++ 语言中，由 const 或 constexpr 关键字限定的全局对象已具有内部链接性（internal linkage），不应再被 static 关键字限定。",
        "tag": "global",
        "related": "ID_staticInHeader",
        "standard": "ISO/IEC 14882:2003 7.1.1(6),ISO/IEC 14882:2011 7.1.1(7)"
        },
    "ID_staticInHeader": {
        "checkPoint": "头文件中不应使用静态声明",
        "level": "warning",
        "comment": "头文件中由 static 关键字声明的对象、数组或函数，会在每个包含该头文件的翻译单元或模块中生成副本造成数据冗余，如果将静态数据误用作全局数据也会造成逻辑错误。",
        "tag": "global",
        "related": "ID_unsuitableDeclaration",
        "standard": "ISO/IEC 9899:1999 6.2.2(3),ISO/IEC 9899:2011 6.2.2(3),ISO/IEC 14882:2003 3.5(3),ISO/IEC 14882:2011 3.5(3)"
        },
    "ID_nameTooShort": {
        "checkPoint": "全局名称应遵循合理的命名方式",
        "level": "suggestion",
        "comment": "全局名称应具有标识性，长度不应过短，否则易与局部名称产生冲突。",
        "config": [
            "minVariableNameLength: 全局对象名称长度下限，小于则报出",
            "minFunctionNameLength: 全局函数名称长度下限，小于则报出",
            "minNameSpaceNameLength: 全局命名空间名称长度下限，小于则报出",
            "minTypeNameLength: 全局类型名称长度下限，小于则报出"
            ],
        "tag": "global",
        "related": "ID_badName",
        "reference": "C++ Core Guidelines NL.7"
        },
    "ID_if_semicolon": {
        "checkPoint": "if 语句不应被分号隔断",
        "level": "error",
        "comment": "if 语句不应被分号隔断。",
        "tag": "control",
        "reference": "CWE-670"
        },
    "ID_if_identicalCondition": {
        "checkPoint": "在 if...else-if 分枝中不应有重复的条件",
        "level": "error",
        "comment": "if...else-if 分枝的条件不应有重复，否则相同条件排在前面的分枝会得以执行，而排在后面的分枝得不到执行机会。",
        "tag": "control",
        "related": "ID_if_hiddenCondition",
        "reference": "CWE-561,CWE-670"
        },
    "ID_if_hiddenCondition": {
        "checkPoint": "在 if...else-if 分枝中不应有被遮盖的条件",
        "level": "error",
        "comment": "if...else-if 分枝中，如果前面的条件被满足，后面的分枝就不会被执行，所以如果前面的条件是后面条件的一部分，或者前面的条件包含后面的条件，即使后面的条件可以被满足，其分枝也得不到执行机会。",
        "tag": "control",
        "related": "ID_if_identicalCondition",
        "reference": "CWE-561,CWE-670"
        },
    "ID_if_identicalBlock": {
        "checkPoint": "if 分枝和 else 分枝的代码不应完全相同",
        "level": "error",
        "comment": "if 分枝和 else 分枝完全相同会使条件判断失去意义，往往是由复制粘贴造成的错误。",
        "tag": "control",
        "related": "ID_if_identicalElseIfBlock,ID_if_identicalImplicitElseBlock",
        "reference": "CWE-670"
        },
    "ID_if_identicalElseIfBlock": {
        "checkPoint": "if...else-if 各分枝的代码不应完全相同",
        "level": "warning",
        "comment": "内容完全相同的分枝是没有意义的，也可能是由复制粘贴造成的错误。",
        "config": [
            "blockTokenCountThreshold: 分枝符号数量阈值，不检查符号数量小于该值的分枝"
            ],
        "tag": "control",
        "related": "ID_if_identicalBlock",
        "reference": "CWE-670"
        },
    "ID_if_identicalImplicitElseBlock": {
        "checkPoint": "if 分枝和隐含的 else 分枝代码不应完全相同",
        "level": "warning",
        "comment": "带有 return、throw 或 break 等子句的 if 语句，其同一作用域的后续代码相当于它的 else 分枝，显然这种隐含的 else 分枝与 if 分枝完全相同是没有意义的，很可能是由复制粘贴造成的错误。",
        "tag": "control",
        "related": "ID_if_identicalElseIfBlock,ID_if_identicalSucceedingBlock",
        "reference": "CWE-670"
        },
    "ID_if_identicalSucceedingBlock": {
        "checkPoint": "没有 else 子句的 if 语句与其后续代码相同是可疑的",
        "level": "suspicious",
        "comment": "if 语句与其同一作用域的后续代码完全相同是可疑的，可能是由复制粘贴造成的错误。",
        "tag": "control",
        "related": "ID_if_identicalImplicitElseBlock",
        "reference": "CWE-670"
        },
    "ID_if_commonStatements": {
        "checkPoint": "if 分枝和 else 分枝的起止语句不应相同",
        "level": "suggestion",
        "comment": "如果 if 分枝和 else 分枝的起止语句相同，应将其从分枝结构中提取出来，否则重复的代码不利于阅读和维护。",
        "tag": "control",
        "related": "ID_if_identicalBlock",
        "reference": "CWE-670,C++ Core Guidelines ES.3"
        },
    "ID_if_scope": {
        "checkPoint": "if 语句作用域的范围不应有误",
        "level": "warning",
        "comment": "if 语句作用域的范围不应有误。",
        "tag": "control",
        "related": "ID_if_brace",
        "reference": "CWE-483"
        },
    "ID_if_mayBeElseIf": {
        "checkPoint": "如果 if 关键字前面是右大括号，if 关键字应另起一行",
        "level": "suspicious",
        "comment": "当 if 关键字前面是右大括号，且 if 关键字与该大括号在同一行时，属于不良换行方式，易造成 else 等关键字的遗漏。",
        "tag": "control"
        },
    "ID_if_assignment": {
        "checkPoint": "if 语句的条件不应为赋值表达式",
        "level": "warning",
        "comment": "虽然语言允许在 if 语句的条件中赋值，但 = 和 == 极易混淆，建议所有产生 bool 型结果的表达式，都不要包含赋值运算符。",
        "tag": "control",
        "config": [
            "allowEnclosedAssignment: 是否放过括号括起来的赋值表达式"
            ],
        "related": "ID_assignmentAsSubExpression",
        "reference": "CWE-480,CWE-481,CWE-783"
        },
    "ID_if_brace": {
        "checkPoint": "if 分枝中的语句应该用大括号括起来",
        "level": "suggestion",
        "comment": "组成 if 分枝的语句应为大括号括起来的复合语句，即使该复合语句只包含一条语句。",
        "tag": "control",
        "related": "ID_do_brace,ID_for_brace,ID_while_brace,ID_switch_brace",
        "reference": "MISRA C 2004 14.9,MISRA C 2012 15.6,MISRA C++ 2008 6-4-1"
        },
    "ID_if_emptyBlock": {
        "checkPoint": "if 语句不应为空",
        "level": "warning",
        "comment": "空的 if 语句或 else 子句无实际意义，往往是残留代码或功能未实现。",
        "tag": "control",
        "reference": "CWE-1071"
        },
    "ID_if_missingEndingElse": {
        "checkPoint": "所有 if...else-if 分枝都应以 else 子句结束",
        "level": "suggestion",
        "comment": "所有 if...else-if 分枝都以 else 子句结束是“防御性编程”思想的良好体现。",
        "tag": "control",
        "related": "ID_switch_missingDefault",
        "reference": "MISRA C 2012 15.7,MISRA C++ 2008 6-4-2"
        },
    "ID_while_semicolon": {
        "checkPoint": "while 语句不应被分号隔断",
        "level": "error",
        "comment": "while 语句不应被分号隔断。",
        "tag": "control",
        "reference": "CWE-670"
        },
    "ID_while_uncondBroken": {
        "checkPoint": "while 语句中不应存在无条件的跳转语句",
        "level": "error",
        "comment": "不受条件限制的 return、throw 或 break 语句会使循环失效，不受条件限制的 continue 语句会使其后面的代码失效，如果其后没有代码，该 continue 语句是没有意义的。",
        "tag": "control",
        "related": "ID_uncondJump,ID_for_uncondBroken",
        "reference": "CWE-670"
        },
    "ID_while_assignment": {
        "checkPoint": "while 语句的条件不应为赋值表达式",
        "level": "warning",
        "comment": "虽然语言允许在 while 语句的条件中赋值，但 = 和 == 极易混淆，建议所有产生 bool 型结果的表达式，都不要包含赋值运算符。",
        "tag": "control",
        "related": "ID_if_assignment",
        "reference": "CWE-480,CWE-783"
        },
    "ID_while_scope": {
        "checkPoint": "while 语句作用域的范围不应有误",
        "level": "warning",
        "comment": "while 语句作用域的范围不应有误。",
        "tag": "control",
        "related": "ID_while_brace",
        "reference": "CWE-483"
        },
    "ID_while_brace": {
        "checkPoint": "while 循环体应该用大括号括起来",
        "level": "suggestion",
        "comment": "while 循环体应为大括号括起来的复合语句，即使该复合语句只包含一条语句。",
        "tag": "control",
        "related": "ID_do_brace,ID_for_brace,ID_if_brace,ID_switch_brace,ID_switch_onlyDefault,ID_switch_onlyOneCase",
        "reference": "MISRA C 2004 14.8,MISRA C 2012 15.6,MISRA C++ 2008 6-3-1"
        },
    "ID_while_emptyBlock": {
        "checkPoint": "while 循环体不应为空",
        "level": "suggestion",
        "comment": "空的 while 循环将功能全部压缩到了条件表达式中，各子句的职责划分不明确，可读性较差。",
        "tag": "control",
        "reference": "CWE-1071,C++ Core Guidelines ES.85"
        },
    "ID_do_emptyBlock": {
        "checkPoint": "do-while 循环体不应为空",
        "level": "suggestion",
        "comment": "空的 do-while 循环将功能全部压缩到了条件表达式中，各子句的职责划分不明确，可读性较差。",
        "tag": "control",
        "related": "ID_while_emptyBlock",
        "reference": "CWE-1071,C++ Core Guidelines ES.85"
        },
    "ID_do_suspiciousContinue": {
        "checkPoint": "注意 do-while(0) 中可疑的 continue 语句",
        "level": "warning",
        "comment": "continue 语句和 break 语句在语义上是不同的，但在 do-while(0) 中的功效是一样的。",
        "tag": "control",
        "reference": "CWE-670"
        },
    "ID_do_brace": {
        "checkPoint": "do-while 循环体应该用大括号括起来",
        "level": "suggestion",
        "comment": "do-while 循环体应为大括号括起来的复合语句，即使该复合语句只包含一条语句。",
        "tag": "control",
        "related": "ID_for_brace,ID_if_brace,ID_switch_brace,ID_while_brace",
        "reference": "MISRA C 2004 14.9,MISRA C 2012 15.6,MISRA C++ 2008 6-3-1"
        },
    "ID_do_deprecated": {
        "checkPoint": "不建议使用 do 语句",
        "level": "suggestion",
        "comment": "do 语句的终止条件在末尾，且第一次执行时不检查终止条件，易被误用。",
        "tag": "control",
        "reference": "C++ Core Guidelines ES.75"
        },
    "ID_for_semicolon": {
        "checkPoint": "for 语句不应被分号隔断",
        "level": "error",
        "comment": "for 语句不应被分号隔断。",
        "tag": "control",
        "related": "ID_do_brace,ID_if_brace,ID_switch_brace,ID_while_brace",
        "reference": "CWE-670"
        },
    "ID_for_uncondBroken": {
        "checkPoint": "for 语句中不应存在无条件的跳转语句",
        "level": "error",
        "comment": "无条件的 return、throw 或 break 语句会使循环失效，无条件的 continue 语句会使其后面的代码失效，如果其后没有代码时，该 continue 语句是没有意义的。",
        "tag": "control",
        "related": "ID_uncondJump,ID_while_uncondBroken",
        "reference": "CWE-670"
        },
    "ID_for_scope": {
        "checkPoint": "for 语句作用域的范围不应有误",
        "level": "warning",
        "comment": "for 语句作用域的范围不应有误。",
        "tag": "control",
        "related": "ID_for_brace",
        "reference": "CWE-483"
        },
    "ID_for_simplification": {
        "checkPoint": "for 语句没有明确的循环变量时应改用 while 语句",
        "level": "suggestion",
        "comment": "如果没有明确的循环变量，则应改用 while 循环，避免误导维护者。",
        "tag": "control",
        "reference": "C++ Core Guidelines ES.73"
        },
    "ID_for_brace": {
        "checkPoint": "for 循环体应该用大括号括起来",
        "level": "suggestion",
        "comment": "for 循环体应为大括号括起来的复合语句，即使该复合语句只包含一条语句。",
        "tag": "control",
        "reference": "MISRA C 2004 14.8,MISRA C 2012 15.6,MISRA C++ 2008 6-3-1"
        },
    "ID_switch_invalidStatement": {
        "checkPoint": "switch 语句中任何子句都应从属于某个 case 或 default 分枝",
        "level": "error",
        "comment": "switch 语句中任何子句都应从属于某个 case 或 default 分枝，否则不会被执行。",
        "tag": "control",
        "reference": "CWE-561,MISRA C 2012 16.1,MISRA C++ 2008 6-4-3"
    },
    "ID_switch_identicalBranch": {
        "checkPoint": "不应存在内容完全相同的 case 分枝",
        "level": "warning",
        "comment": "内容完全相同的分枝应合并为一个分枝，也可能是由复制粘贴造成的错误。",
        "tag": "control",
        "config": [
            "branchTokenCountThreshold: 分枝符号数量阈值，不检查符号数量小于该值的分枝"
            ],
        "related": "ID_if_identicalBlock,ID_if_identicalElseIfBlock",
        "reference": "C++ Core Guidelines ES.3"
    },
    "ID_switch_breakOmitted": {
        "checkPoint": "switch 语句的每个非空分枝都应该用无条件的 break 或 return 语句终止",
        "level": "warning",
        "comment": "在 switch 语句的分枝中，break 或 return 语句的缺失是导致错误的常见原因。",
        "tag": "control",
        "standard": "ISO/IEC 9899:1999 6.8.4.2(7),ISO/IEC 9899:2011 6.8.4.2(7),ISO/IEC 14882:2003 6.4.2(6),ISO/IEC 14882:2011 6.4.2(6),ISO/IEC 14882:2017 10.6.5(1 2 3)",
        "reference": "CWE-484,C++ Core Guidelines ES.78,MISRA C 2004 15.2,MISRA C 2012 16.3,MISRA C++ 2008 6-4-5"
    },
    "ID_switch_semicolon": {
        "checkPoint": "switch 语句不应被分号隔断",
        "level": "error",
        "comment": "switch 语句不应被分号隔断。",
        "tag": "control",
        "reference": "CWE-670"
        },
    "ID_switch_emptyBlock": {
        "checkPoint": "switch 语句不应为空",
        "level": "warning",
        "comment": "空的 switch 语句没有意义。",
        "tag": "control",
        "reference": "CWE-1071,MISRA C++ 2008 6-4-8"
        },
    "ID_switch_bool": {
        "checkPoint": "switch 语句的条件不应为 bool 型",
        "level": "warning",
        "comment": "如果条件为 bool 型，应改用 if-else 语句使代码的结构更清晰。",
        "tag": "control",
        "reference": "MISRA C 2004 15.4,MISRA C 2012 16.7,MISRA C++ 2008 6-4-7"
        },
    "ID_switch_badFormedCase": {
        "checkPoint": "case 和 default 标签应直接从属于 switch 语句",
        "level": "suggestion",
        "comment": "不直接从属于 switch 语句的 case 或 default 标签用于非结构性跳转，是公认的不良实现。",
        "tag": "control",
        "related": "ID_forbidGotoBlocks",
        "reference": "MISRA C 2004 15.1,MISRA C 2012 16.2,MISRA C++ 2008 6-4-4"
        },
    "ID_switch_missingDefault": {
        "checkPoint": "switch 语句应配有 default 分枝",
        "level": "suggestion",
        "comment": "所有 switch 语句都配有 default 分枝是“防御性编程”思想的良好体现。",
        "tag": "control",
        "related": "ID_if_missingEndingElse",
        "reference": "CWE-478,MISRA C 2012 16.4,MISRA C++ 2008 6-4-6"
        },
    "ID_try_emptyBlock": {
        "checkPoint": "try 关键字的作用域不应为空",
        "level": "warning",
        "comment": "try 关键字的作用域，即 try 关键字后的复合语句不应为空，否则无实际意义，往往是残留代码或功能未实现。",
        "tag": "control",
        "reference": "CWE-1071"
        },
    "ID_catch_emptyBlock": {
        "checkPoint": "catch 子句不应为空",
        "level": "warning",
        "comment": "空的 catch 子句仅捕获异常而未作任何处理，相当于掩盖了异常。",
        "tag": "control",
        "reference": "CWE-391,CWE-1069,CWE-1071"
        },
    "ID_literal_misspelling": {
        "checkPoint": "字符串常量中不应存在拼写错误",
        "level": "warning",
        "comment": "如果含有拼写错误的常量字符串对用户可见，也可以认为是产品的一种 bug，会对用户造成困扰，故应认真对待。",
        "tag": "literal",
        "related": "ID_misspelling"
        },
    "ID_literal_suspiciousChar": {
        "checkPoint": "转义字符的反斜杠不可误写成斜杠",
        "level": "warning",
        "comment": "将转义字符的反斜杠误写成斜杠是常见笔误，但仍可通过编译，造成不易察觉的问题。",
        "tag": "literal",
        "related": "ID_literal_multicharacter",
        "standard": "ISO/IEC 9899:1999 6.4.4.4(10)-implementation,ISO/IEC 9899:2011 6.4.4.4(10)-implementation,ISO/IEC 14882:2011 2.13.2(1)-implementation,ISO/IEC 14882:2011 2.14.3(1)-implementation,ISO/IEC 14882:2017 5.13.3(2)-implementation"
        },
    "ID_literal_hardCodeChar": {
        "checkPoint": "在字符常量中用转义字符表示制表符和控制字符",
        "level": "warning",
        "comment": "未经转义的制表符和控制字符不利于阅读和维护。",
        "tag": "literal",
        "related": "ID_literal_hardCodeString"
        },
    "ID_literal_hardCodeString": {
        "checkPoint": "在字符串常量中用转义字符表示制表符和控制字符",
        "level": "warning",
        "comment": "未经转义的制表符和控制字符不利于阅读和维护。",
        "tag": "literal",
        "related": "ID_literal_hardCodeChar"
        },
    "ID_hardcodedIP": {
        "checkPoint": "与网络地址相关的信息不应写入代码",
        "level": "warning",
        "comment": "在代码中记录网络地址不利于维护和移植，也容易暴露产品的网络结构，属于安全隐患。",
        "tag": "security",
        "related": "ID_addressExposure"
        },
    "ID_literal_nonStandardEsc": {
        "checkPoint": "不应使用非标准转义字符",
        "level": "warning",
        "comment": "非标准转义字符没有可移植性，也可能是忘了将反斜杠转义。",
        "tag": "literal",
        "standard": "ISO/IEC 9899:1999 6.4.4.4,ISO/IEC 9899:2011 6.4.4.4,ISO/IEC 14882:2003 2.13.2(3)-undefined,ISO/IEC 14882:2011 2.14.3(3)-implementation,ISO/IEC 14882:2017 5.13.3(7)-implementation",
        "reference": "MISRA C 2004 4.1,MISRA C++ 2008 2-13-1"
        },
    "ID_literal_hybridConcat": {
        "checkPoint": "不应连接不同前缀的字符串常量",
        "level": "warning",
        "comment": "连接不同前缀的字符串常量会导致标准未定义或由实现定义的行为。",
        "tag": "literal",
        "config": [
            "allowPrefixedConcatUnprefixed: 是否允许有前缀和无前缀的字符串连接"
            ],
        "standard": "ISO/IEC 9899:1999 6.4.5(4),ISO/IEC 9899:2011 6.4.5(5)-implementation,ISO/IEC 14882:2003 2.13.4(3)-undefined,ISO/IEC 14882:2011 2.14.5(13)-implementation",
        "reference": "MISRA C++ 2008 2-13-5"
        },
    "ID_literal_oddConcat": {
        "checkPoint": "小心遗漏逗号导致的非预期字符串连接",
        "level": "warning",
        "comment": "注意可能导致非预期结果的字符串连接，尤其在初始化列表中，小心逗号被遗漏。",
        "tag": "literal"
        },
    "ID_literal_forbidOct": {
        "checkPoint": "禁用 8 进制常量",
        "level": "suggestion",
        "comment": "8 进制不像 10 进制那样符合人们的常规思维，也不像 2 进制或 16 进制那样便于展示数据的存储格式，而且 C/C++ 语言中 8 进制表示法只是在数字前置 0，与十进制过于相似，易被误用。",
        "tag": "literal",
        "reference": "MISRA C 2004 7.1,MISRA C 2012 7.1,MISRA C++ 2008 2-13-2"
        },
    "ID_literal_confusingSuffix": {
        "checkPoint": "常量后缀由应由大写字母组成",
        "level": "warning",
        "comment": "小写字母“l”极易与数字“1”混淆，为了提高可读性，常量后缀均应由大写字母组成。",
        "tag": "literal",        
        "config": [ 
            "allSuffixCharMustBeUpperCase: 要求后缀中所有字符均为大写，或只要求小写字符“l”不得用于后缀"
            ],
        "reference": "C++ Core Guidelines NL.19,MISRA C 2012 7.3,MISRA C++ 2008 2-13-4"
        },
    "ID_literal_nonStandardSuffix": {
        "checkPoint": "不应使用非标准常量后缀",
        "level": "suggestion",
        "comment": "整数常量后缀应为 L、LL、UL、ULL，浮点数常量的后缀应为 L、f 或 F，非标准后缀不具备可移植性。",
        "tag": "literal",
        "related": "ID_literal_confusingSuffix",
        "standard": "ISO/IEC 9899:1999 6.4.4.1(5),ISO/IEC 9899:1999 6.4.4.2(4),ISO/IEC 9899:2011 6.4.4.1(5),ISO/IEC 9899:2011 6.4.4.2(4),ISO/IEC 14882:2003 2.14.2(2),ISO/IEC 14882:2003 2.14.4(1),ISO/IEC 14882:2011 2.14.2(2),ISO/IEC 14882:2011 2.14.4(1),ISO/IEC 14882:2017 5.13.2(2),ISO/IEC 14882:2017 5.13.4(1)"
        },
    "ID_literal_magicNumber": {
        "checkPoint": "不应存在 magic number",
        "level": "suggestion",
        "comment": "直接出现在代码中的字面数值称为 magic number，使人难以理解其含义，不利于阅读和维护，应改用具有适当名称的常量或枚举项。",
        "tag": "literal",
        "related": "ID_literal_magicString",
        "reference": "C++ Core Guidelines ES.45"
        },
    "ID_literal_magicString": {
        "checkPoint": "不应存在 magic string",
        "level": "suggestion",
        "comment": "直接出现在代码中的字面常量字符串称为 magic string，不利于阅读和维护，应改用具有适当名称的常量。",
        "tag": "literal",
        "related": "ID_literal_magicNumber",
        "reference": "C++ Core Guidelines ES.45"
        },
    "ID_literal_multicharacter": {
        "checkPoint": "不应使用多字符常量",
        "level": "suggestion",
        "comment": "“多字符常量（multi-character literal）”指单引号之间有多个字符或非基本字符的常量，这种常量的值是由实现定义的，而且在形式上与字符或字符串常量非常相似，易被误用，故建议禁用。",
        "tag": "literal",
        "standard": "ISO/IEC 9899:1999 6.4.4.4(10)-implementation,ISO/IEC 9899:2011 6.4.4.4(10)-implementation,ISO/IEC 14882:2011 2.13.2(1)-implementation,ISO/IEC 14882:2011 2.14.3(1)-implementation,ISO/IEC 14882:2017 5.13.3(2)-implementation",
        "related": "ID_literal_suspiciousChar"
        },
    "ID_nonStdDirective": {
        "checkPoint": "不应使用非标准预编译指令",
        "level": "warning",
        "comment": "非标准预编译指令往往属于某种编译器独有，在有可移植性要求的代码中应避免使用。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.10(1),ISO/IEC 9899:2011 6.10(1),ISO/IEC 14882:2003 16(1),ISO/IEC 14882:2011 16(1),ISO/IEC 14882:2017 19(1)",
        "reference": "MISRA C 2004 19.16,MISRA C 2012 20.13"
        },
    "ID_forbidPragmaDirective": {
        "checkPoint": "避免使用 pragma 指令",
        "level": "warning",
        "comment": "为了提高可移植性，应避免使用由实现定义的 pragma 指令。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.10.6(1)-implementation,ISO/IEC 9899:2011 6.10.6(1)-implementation",
        "reference": "MISRA C++ 2008 16-6-1"
        },
    "ID_explicitLineDirective": {
        "checkPoint": "非自动生成的代码中不应出现 line 指令",
        "level": "warning",
        "comment": "在非自动生成的代码中没有必要使用 line 指令，否则会干扰编译器的输出，使问题难以定位。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.10.4,ISO/IEC 9899:2011 6.10.4"
        },
    "ID_illFormedDirective": {
        "checkPoint": "不应出现非标准格式的预编译指令",
        "level": "warning",
        "comment": "非标准格式的预编译指令往往意味着错误，也会导致标准未定义的行为。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.10(1),ISO/IEC 9899:1999 6.10.1(3)-undefined,ISO/IEC 9899:2011 6.10(1),ISO/IEC 9899:2011 6.10.1(4)-undefined,ISO/IEC 14882:2003 16.1(4)-undefined,ISO/IEC 14882:2003 16.2(4)-undefined,ISO/IEC 14882:2003 16.4(3)-undefined,ISO/IEC 14882:2003 16.4(5)-undefined,ISO/IEC 14882:2011 16.1(4)-undefined,ISO/IEC 14882:2011 16.2(4)-undefined,ISO/IEC 14882:2011 16.4(3)-undefined,ISO/IEC 14882:2011 16.4(5)-undefined",
        "reference": "MISRA C++ 2008 16-0-7,MISRA C++ 2008 16-0-8,MISRA C++ 2008 16-1-1"
        },
    "ID_warningDisabled": {
        "checkPoint": "对编译警告的屏蔽应慎重",
        "level": "suggestion",
        "comment": "编译器一般允许使用预编译指令屏蔽某些编译警告，但对于反映风险或安全问题的警告不应屏蔽。",
        "tag": "precompile",
        "related": "ID_warningDefault"
        },
    "ID_warningDefault": {
        "checkPoint": "在高级别的警告设置下编译",
        "level": "suggestion",
        "comment": "编译器一般允许设定编译警告的级别，级别越高关注的问题就越多，也可以将警告设为错误，当有警告产生时停止编译，建议代码在高级别的警告设置下编译。",
        "tag": "precompile",
        "related": "ID_warningDisabled",
        "reference": "SEI CERT MSC00-C"
        },
    "ID_macro_badName": {
        "checkPoint": "宏应遵循合理的命名方式",
        "level": "suggestion",
        "comment": "宏的名称应采用全大写字母的形式，非宏名称则应包含小写字母。",
        "tag": "precompile",
        "related": "ID_badName",
        "reference": "C++ Core Guidelines ES.32,C++ Core Guidelines ES.9"
        },
    "ID_macro_insufficientArgs": {
        "checkPoint": "宏的实参个数不可小于形参个数",
        "level": "error",
        "comment": "宏的实参个数小于形参个数是不符合 C/C++ 标准的，参数个数不一致必然意味着某种错误，然而在某些编译环境下却可以通过编译。",
        "tag": "precompile",
        "related": "ID_macro_redundantArgs",
        "standard": "ISO/IEC 9899:1999 6.10.3(4),ISO/IEC 9899:2011 6.10.3(4),ISO/IEC 14882:2003 16.3(4),ISO/IEC 14882:2011 16.3(4)",
        "reference": "CWE-628,MISRA C 2004 19.8"
        },
    "ID_macro_redundantArgs": {
        "checkPoint": "宏的实参个数不可大于形参个数",
        "level": "warning",
        "comment": "宏的实参个数大于形参个数是不符合 C/C++ 标准的，多余的宏参数是没有意义的，然而在某些编译环境下却可以通过编译。",
        "tag": "precompile",
        "related": "ID_macro_insufficientArgs",
        "standard": "ISO/IEC 9899:1999 6.10.3(4),ISO/IEC 9899:2011 6.10.3(4),ISO/IEC 14882:2003 16.3(4),ISO/IEC 14882:2011 16.3(4)",
        "reference": "CWE-628"
        },
    "ID_macro_sideEffectArgs": {
        "checkPoint": "宏的实参不应有副作用",
        "level": "warning",
        "comment": "当宏参数有“副作用（side effect）”时，如果宏定义中没有或多次引用到该参数，会导致意料之外的错误。",
        "tag": "precompile",
        "related": "ID_sideEffectAssertion,ID_macro_function",
        "reference": "SEI CERT PRE31-C"
        },
    "ID_macro_paramNotEnclosed": {
        "checkPoint": "表达式中的宏参数应该用括号括起来",
        "level": "warning",
        "comment": "由于宏只做文本处理，不考虑运算符优先级等问题，故应将宏参数用括号括起来，否则易产生意料之外的错误。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.10.3.5(4),ISO/IEC 9899:2011 6.10.3.5(4)",
        "reference": "CWE-783,MISRA C++ 2008 16-0-6"
        },
    "ID_macro_expNotEnclosed": {
        "checkPoint": "可作为子表达式的宏定义应该用括号括起来",
        "level": "warning",
        "comment": "由于宏只做文本处理，不考虑运算符优先级等问题，可作为子表达式的宏定义应该用括号括起来，否则易产生意料之外的错误。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.10.3.5(4),ISO/IEC 9899:2011 6.10.3.5(4)",
        "reference": "CWE-783,MISRA C 2004 19.10,MISRA C 2012 20.7"
        },
    "ID_macro_stmtNotEnclosed": {
        "checkPoint": "由多个语句组成的宏定义应该用 do-while(0) 括起来",
        "level": "warning",
        "comment": "可以作为一条语句使用的宏，且宏包含多个并列子句时，应该用“do {”和“} while(0)”括起来，否则易造成作用域的混乱。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.10.3.5(4),ISO/IEC 9899:2011 6.10.3.5(4)",
        "related": "ID_if_scope,ID_while_scope,ID_for_scope",
        "reference": "CWE-483"
        },
    "ID_macro_defineReserved": {
        "checkPoint": "不可定义具有保留意义的宏名称",
        "level": "warning",
        "comment": "重新定义已有特殊用途的名称会导致标准未定义的行为，也会使代码陷入难以维护的境地。",
        "config": [
            "keywordAsReserved: 是否将关键字作为保留名称",
            "stdNameAsReserved: 是否将标准库中的名称作为保留名称",
            "underscoreAsReserved: 是否将下划线开头的名称作为保留名称",
            "reservedNames: 用户指定的保留名称"
            ],
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 7.1.3(2)-undefined,ISO/IEC 9899:2011 7.1.3(2)-undefined,ISO/IEC 14882:2003 16.8(3)-undefined,ISO/IEC 14882:2011 16.8(4)-undefined",
        "related": "ID_macro_undefReserved,ID_reservedName",
        "reference": "MISRA C 2012 20.4,MISRA C 2012 21.1,MISRA C++ 2008 17-0-1"
        },
    "ID_macro_undefReserved": {
        "checkPoint": "不可取消定义具有保留意义的宏名称",
        "level": "warning",
        "comment": "取消定义已有特殊用途的宏会导致标准未定义的行为，也会使代码陷入难以维护的境地。",
        "config": [
            "keywordAsReserved: 是否将关键字作为保留名称",
            "stdNameAsReserved: 是否将标准库中的名称作为保留名称",
            "underscoreAsReserved: 是否将下划线开头的名称作为保留名称",
            "reservedNames: 用户指定的保留名称"
            ],
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 7.1.3(3)-undefined,ISO/IEC 9899:2011 7.1.3(3)-undefined,ISO/IEC 14882:2003 16.8(3)-undefined,ISO/IEC 14882:2011 16.8(4)-undefined",
        "related": "ID_macro_defineReserved,ID_reservedName",
        "reference": "MISRA C 2012 21.1,MISRA C++ 2008 17-0-1"
        },
    "ID_macro_complexConcat": {
        "checkPoint": "宏定义中的 # 和 ## 运算符不应嵌套使用",
        "level": "warning",
        "comment": "# 和 ## 运算符的求值顺序在标准中是未声明的，不应嵌套使用。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.10.3.2(2)-unspecified,ISO/IEC 9899:1999 6.10.3.3(3)-unspecified,ISO/IEC 9899:2011 6.10.3.2(2)-unspecified,ISO/IEC 9899:2011 6.10.3.3(3)-unspecified,ISO/IEC 14882:2003 16.3.2(2)-unspecified,ISO/IEC 14882:2003 16.3.3(3)-unspecified,ISO/IEC 14882:2011 16.3.2(2)-unspecified,ISO/IEC 14882:2011 16.3.3(3)-unspecified,ISO/IEC 14882:2017 19.3.2(2)-unspecified,ISO/IEC 14882:2017 19.3.3(3)-unspecified",
        "reference": "MISRA C 2004 19.12,MISRA C 2012 20.11,MISRA C++ 2008 16-3-1"
        },
    "ID_macro_const": {
        "checkPoint": "不应使用宏定义常量",
        "level": "suggestion",
        "comment": "宏用于文本处理，不受作用域等语言规则限制，不应使用宏实现常量等语言层面的概念。",
        "tag": "precompile",
        "related": "ID_macro_typeid,ID_macro_function",
        "reference": "C++ Core Guidelines ES.31,C++ Core Guidelines Enum.1"
        },
    "ID_macro_typeid": {
        "checkPoint": "不应使用宏定义类型",
        "level": "suggestion",
        "comment": "宏用于文本处理，不受作用域等语言规则限制，不应使用宏实现类型等语言层面的概念。",
        "tag": "precompile",
        "related": "ID_macro_sideEffectArgs,ID_macro_const,ID_macro_function",
        "reference": "C++ Core Guidelines ES.30"
        },
    "ID_macro_function": {
        "checkPoint": "可由函数实现的功能不应使用宏实现",
        "level": "suggestion",
        "comment": "宏用于文本处理，不受作用域、参数传递、重载等语言规则限制，且难以调试，可由函数实现的功能不应使用宏实现。",
        "tag": "precompile",
        "related": "ID_macro_sideEffectArgs,ID_macro_const,ID_macro_typeid",
        "reference": "C++ Core Guidelines ES.31,MISRA C 2004 19.7,MISRA C 2012 Dir 4.9,MISRA C++ 2008 16-0-4"
        },
    "ID_nestedTooDeep": {
        "checkPoint": "作用域及类型嵌套不应过深",
        "level": "suggestion",
        "comment": "作用域及类型嵌套过深会造成阅读和维护困难。",
        "config": [
            "maxFunctionNestedDepth: 函数作用域最大嵌套层数，超过则报出",
            "maxInlineFunctionNestedDepth: 内联函数作用域最大嵌套层数，超过则报出",
            "maxLambdaNestedDepth: 函数作用域最大嵌套层数，超过则报出",
            "maxTypeNestedDepth: 类型最大嵌套层数，超过则报出",
            "maxNamespaceNestedDepth: 命名空间最大嵌套层数，超过则报出"
            ],
        "tag": "function"
        },
    "ID_functionRepetition": {
        "checkPoint": "避免重复的函数实现",
        "level": "suggestion",
        "comment": "重复的或过于相似的代码不利于维护。",
        "tag": "function",
        "config": [
            "tokenCountThreshold: 符号数量阈值，小于此阈值的函数不参与比较",
            "repetitionRateThreshold: 函数相似度阈值，超过则报出"
            ],
        "reference": "CWE-1041,C++ Core Guidelines ES.3"
        },
    "ID_invalidCondition": {
        "checkPoint": "作为条件的逻辑表达式不应恒为真或恒为假",
        "level": "warning",
        "comment": "以恒为真或恒为假的表达式作为条件是没有意义的，属于逻辑错误。",
        "tag": "expression",
        "related": "ID_constLogicExpression",
        "reference": "CWE-570,CWE-571,MISRA C 2004 13.7,MISRA C 2012 14.3,MISRA C++ 2008 0-1-2"
        },
    "ID_nullDerefInExp": {
        "checkPoint": "注意逻辑表达式内的空指针解引用",
        "level": "error",
        "comment": "在逻辑表达式中，需注意逻辑关系以及运算符优先级，不可出现空指针解引用等问题。",
        "tag": "pointer",
        "standard": "ISO/IEC 9899:1999 6.3.2.1(1)-undefined,ISO/IEC 9899:1999 6.5.3.2(4)-undefined,ISO/IEC 9899:2011 6.3.2.1(1)-undefined,ISO/IEC 9899:2011 6.5.3.2(4)-undefined,ISO/IEC 14882:2003 8.3.2(4)-undefined,ISO/IEC 14882:2011 8.3.2(5)-undefined",
        "reference": "CWE-476,CWE-783,C++ Core Guidelines ES.65"
        },
    "ID_nullDerefInScp": {
        "checkPoint": "避免空指针解引用",
        "level": "error",
        "comment": "通过指针的值访问相应地址中的数据称为“解引用（dereference）”，空指针是没有指向任何数据的指针，空指针解引用是一种逻辑错误，会导致标准未定义的行为。",
        "tag": "pointer",
        "standard": "ISO/IEC 9899:1999 6.3.2.1(1)-undefined,ISO/IEC 9899:1999 6.5.3.2(4)-undefined,ISO/IEC 9899:2011 6.3.2.1(1)-undefined,ISO/IEC 9899:2011 6.5.3.2(4)-undefined,ISO/IEC 14882:2003 8.3.2(4)-undefined,ISO/IEC 14882:2011 8.3.2(5)-undefined",
        "reference": "CWE-476,C++ Core Guidelines ES.65"
        },
    "ID_divideByZero": {
        "checkPoint": "避免除 0 等计算异常",
        "level": "error",
        "comment": "除 0 等在数学上没有定义的运算、浮点异常、非法指令、段错误等问题称为“计算异常”，意味着程序发生了严重的底层运行时错误，而且这种异常无法用语言层面的常规方法捕获。",
        "tag": "security",
        "related": "ID_sig_illReturn",
        "standard": "ISO/IEC 9899:1999 6.5.5(5)-undefined,ISO/IEC 9899:2011 6.5.5(5)-undefined,ISO/IEC 14882:2003 5.6(4)-undefined,ISO/IEC 14882:2011 5.6(4)-undefined,ISO/IEC 14882:2017 8.6(4)-undefined",
        "reference": "CWE-189,CWE-369,C++ Core Guidelines ES.105"
        },
    "ID_nullDerefAllocRet": {
        "checkPoint": "判断资源分配函数的返回值是否有效",
        "level": "warning",
        "comment": "malloc 等函数在分配失败时返回空指针，如果不加判断直接使用会导致标准未定义的行为。",
        "tag": "resource",
        "standard": "ISO/IEC 9899:1999 7.20.3(1),ISO/IEC 9899:2011 7.22.3(1)",
        "reference": "CWE-252,CWE-476"
        },
    "ID_nullDerefDynamicCast": {
        "checkPoint": "判断 dynamic_cast 转换是否成功",
        "level": "warning",
        "comment": "dynamic_cast 转换指针失败会返回空指针，转换引用失败会抛出异常，如果不作判断则失去了使用 dynamic_cast 的意义。",
        "tag": "pointer",
        "standard": "ISO/IEC 14882:2003 5.2.7(9),ISO/IEC 14882:2011 5.2.7(9)",
        "related": "ID_nonDynamicDownCast",
        "reference": "CWE-476,C++ Core Guidelines C.148"
        },
    "ID_wildPtrDeref": {
        "checkPoint": "不可解引用未初始化的指针",
        "level": "error",
        "comment": "未初始化的指针具有不确定的值，对其解引用会导致标准未定义的行为，往往会造成严重错误。",
        "tag": "pointer",
        "related": "ID_illAccess,ID_localInitialization",
        "standard": "ISO/IEC 9899:1999 6.5.3.2(4)-undefined,ISO/IEC 9899:2011 6.5.3.2(4)-undefined",
        "reference": "CWE-824,C++ Core Guidelines ES.65"
        },
    "ID_danglingDeref": {
        "checkPoint": "不可解引用已被释放的指针",
        "level": "error",
        "comment": "已被释放的指针指向失效的内存空间，对其解引用会导致标准未定义的行为，往往会造成严重错误。",
        "tag": "pointer",
        "related": "ID_illAccess,ID_localAddressFlowOut,ID_illLifetime",
        "standard": "ISO/IEC 9899:1999 6.5.3.2(4)-undefined,ISO/IEC 9899:2011 6.5.3.2(4)-undefined",
        "reference": "CWE-825,C++ Core Guidelines ES.65,SEI CERT EXP54-CPP"
        },
    "ID_sensitiveName": {
        "checkPoint": "公共成员或全局对象不应记录敏感数据",
        "level": "warning",
        "comment": "公共成员、全局对象可被外部代码引用，如果存有敏感数据则可能会被误用或窃取。",
        "tag": "security",
        "reference": "CWE-766"
        },
    "ID_dangerousName": {
        "checkPoint": "避免引用危险符号名称",
        "level": "warning",
        "comment": "弱加密、弱哈希、弱随机、不安全的协议等相关库、函数、类、宏、常量等名称不应出现在代码中。",
        "tag": "security",
        "reference": "CWE-326,CWE-327"
        },
    "ID_badLength": {
        "checkPoint": "memset 等函数长度相关的参数不应有误",
        "level": "error",
        "comment": "对于 memset、memcpy、memmove、memcmp 及同类函数，表示长度的参数不应存在常见笔误。",
        "tag": "buffer",
        "reference": "CWE-130,CWE-805"
        },
    "ID_valueOverflow": {
        "checkPoint": "memset 等函数填充值相关的参数不应有误",
        "level": "error",
        "comment": "memset、memset_s 等函数的填充值参数会被转为 unsigned char 型，所以填充值不应超出 unsigned char 的取值范围。",
        "tag": "buffer",
        "standard": "ISO/IEC 9899:1999 7.21.6.1(2),ISO/IEC 9899:2011 7.24.6.1(2),ISO/IEC 9899:2011 K.3.7.4.1(4)",
        "reference": "CWE-130"
        },
    "ID_qualifierInvalid": {
        "checkPoint": "const、volatile 不可限定引用",
        "level": "error",
        "comment": "在 C++ 语言中，const 或 volatile 可以限定指针，但不可限定引用，否则起不到任何作用。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2003 8.3.2(1),ISO/IEC 14882:2011 8.3.2(1),ISO/IEC 14882:2017 11.3.2(1)"
        },
    "ID_qualifierForPtrAlias": {
        "checkPoint": "const、volatile 限定指针类型的别名是可疑的",
        "level": "suspicious",
        "comment": "如果用 const、volatile 限定指针类型的别名，很可能会造成意料之外的错误。",
        "tag": "declaration",
        "related": "ID_qualifierInvalid",
        "reference": "SEI CERT DCL05-C"
        },
    "ID_qualifierRepeated": {
        "checkPoint": "const、volatile 不应重复",
        "level": "error",
        "comment": "重复的 const 或 volatile 限定符是没意义的，很可能意味着某种错误。",
        "tag": "declaration",
        "related": "ID_badQualifierPosition"
        },
    "ID_forbidVolatile": {
        "checkPoint": "非适当场景禁用 volatile",
        "level": "suggestion",
        "comment": "应在适当的场景中合理使用 volatile，否则会导致优化或同步相关的多种问题。",
        "tag": "declaration",
        "standard": "ISO/IEC 9899:1999 6.7.3(6),ISO/IEC 9899:2011 6.7.3(7),ISO/IEC 14882:2003 7.1.5.1(8),ISO/IEC 14882:2011 7.1.6.1(7)",
        "reference": "C++ Core Guidelines CP.8,C++ Core Guidelines CP.200"
        },
    "ID_sizeof_arrayParameter": {
        "checkPoint": "sizeof 不应作用于数组参数",
        "level": "error",
        "comment": "当函数的形式参数为数组时，实际上是一个指针，对这种参数使用 sizeof 无法获取到数组大小，往往意味着错误。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.7.5.3(7),ISO/IEC 9899:2011 6.7.6.3(7)",
        "reference": "CWE-467"
        },
    "ID_sizeof_zeroComparison": {
        "checkPoint": "sizeof 表达式的结果不应与 0 或负数比较",
        "level": "error",
        "comment": "将 sizeof 表达式的结果与 0 或负数比较往往意味着逻辑错误。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.7.2.1(7)-undefined,ISO/IEC 9899:2011 6.7.2.1(8)-undefined,ISO/IEC 14882:2003 5.3.3(1 6),ISO/IEC 14882:2003 9(3),ISO/IEC 14882:2011 5.3.3(1 6),ISO/IEC 14882:2011 9(3),ISO/IEC 14882:2017 8.3.3(1 6),ISO/IEC 14882:2017 12(4)",
        "reference": "CWE-1025"
        },
    "ID_sizeof_sizeof": {
        "checkPoint": "sizeof 不应再作用于 sizeof 表达式",
        "level": "error",
        "comment": "sizeof(sizeof(...)) 等价于 sizeof(size_t)，在实际应用中没有任何必要写成连续 sizeof 的形式，属于常见笔误，多数由复制粘贴或错误的宏展开导致。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.5.3.4(4),ISO/IEC 9899:2011 6.5.3.4(5),ISO/IEC 14882:2003 5.3.3(6),ISO/IEC 14882:2011 5.3.3(6),ISO/IEC 14882:2017 8.3.3(6)",
        "reference": "CWE-682"
        },
    "ID_unevaluatedSideEffect": {
        "checkPoint": "不可依赖不会生效的副作用",
        "level": "warning",
        "comment": "有些运算符只关注类型，其子表达式不会被求值，子表达式的副作用也不会有实际效果。",
        "tag": "expression",
        "related": "ID_sideEffectAssertion",
        "standard": "ISO/IEC 9899:1999 6.5.3.4(2),ISO/IEC 9899:2011 6.5.3.4(2),ISO/IEC 14882:2003 5.3.3(1),ISO/IEC 14882:2011 5.3.3(1),ISO/IEC 14882:2017 8.3.3(1)",
        "reference": "MISRA C 2004 12.3,MISRA C 2012 13.6,MISRA C++ 2008 5-3-4,SEI CERT EXP44-C,SEI CERT EXP52-CPP"
        },
    "ID_sizeof_NULL": {
        "checkPoint": "C++ 代码中 sizeof 不应作用于 NULL",
        "level": "warning",
        "comment": "标识符 NULL 由实现定义，在 C++ 语言中往往等同于常量 0，sizeof(NULL) 的结果很可能与预期不符。",
        "tag": "expression",
        "related": "ID_deprecatedNULL",
        "standard": "ISO/IEC 14882:2003 C.2.2.3(1)-implementation,ISO/IEC 14882:2011 C.3.2.4(1)-implementation,ISO/IEC 14882:2017 C.5.2.7(1)-implementation",
        "reference": "CWE-351"
        },
    "ID_sizeof_pointer": {
        "checkPoint": "sizeof 作用于指针是可疑的",
        "level": "suspicious",
        "comment": "sizeof 作用于指针的结果是指针的大小，而不是指针指向内容的大小，sizeof 作用于指针很容易造成错误。",
        "tag": "expression",
        "related": "ID_sizeof_pointerDivision",
        "reference": "CWE-467"
        },
    "ID_accessPaddingData": {
        "checkPoint": "不应访问填充数据",
        "level": "warning",
        "comment": "内存中各对象之间可能存在填充数据，这种数据只为实现“内存对齐”而无数值意义，而且填充数据的值是标准未声明的。",
        "tag": "expression",
        "related": "ID_ignorePaddingData",
        "standard": "ISO/IEC 9899:1999 6.2.6.2(5)-unspecified,ISO/IEC 9899:2011 6.2.6.2(5)-unspecified"
        },
    "ID_wrongUseOfReturnValue": {
        "checkPoint": "不可臆断返回值的意义",
        "level": "error",
        "comment": "应遵循接口文档使用接口，不可臆断返回值的意义，否则造成逻辑错误。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 7.21.4,ISO/IEC 9899:2011 7.24.4",
        "reference": "CWE-253"
        },
    "ID_inconsistentFormatArgNum": {
        "checkPoint": "C 格式化字符串需要的参数个数与实际传入的参数个数应一致",
        "level": "error",
        "comment": "如果 C 格式化占位符的数量大于参数的数量，会导致标准未定义的行为，反之多余的参数会失去意义，往往意味着逻辑错误。",
        "tag": "expression",
        "related": "ID_inconsistentFormatArgType,ID_forbidCStringFormat",
        "standard": "ISO/IEC 9899:1999 7.19.6.1(2)-undefined,ISO/IEC 9899:2011 7.21.6.1(2)-undefined",
        "reference": "SEI CERT FIO47-C"
        },
    "ID_inconsistentFormatArgType": {
        "checkPoint": "C 格式化占位符与其对应参数的类型应一致",
        "level": "error",
        "comment": "C 格式化占位符与其对应参数的类型应一致，否则导致标准未定义的行为。",
        "tag": "expression",
        "related": "ID_nonPODVariadicArgument,ID_inconsistentFormatArgNum,ID_forbidCStringFormat",
        "standard": "ISO/IEC 9899:1999 7.19.6.1(9)-undefined,ISO/IEC 9899:2011 7.21.6.1(9)-undefined",
        "reference": "CWE-686,SEI CERT FIO47-C"
        },
    "ID_variableFormatString": {
        "checkPoint": "格式化字符串应为常量",
        "level": "warning",
        "comment": "出于可读性和安全性的考量，格式化字符串最好直接写成常量字符串的形式。",
        "tag": "security",
        "related": "ID_hijack",
        "reference": "CWE-134"
        },
    "ID_addressExposure": {
        "checkPoint": "与内存空间布局相关的信息不可被外界感知",
        "level": "warning",
        "comment": "函数、对象、缓冲区的地址以及相关内存区域的长度等信息不可被外界感知，否则会成为攻击者的线索。",
        "tag": "security",
        "related": "ID_bufferOverflow",
        "reference": "CWE-200"
        },
    "ID_forbidCStringFormat": {
        "checkPoint": "在 C++ 代码中禁用 C 字符串格式化方法",
        "level": "suggestion",
        "comment": "C 字符串格式化方法是不安全的，在编译期无法限定参数的类型和数量，极易产生各种错误。",
        "tag": "expression",
        "related": "ID_forbidVariadicFunction",
        "standard": "ISO/IEC 9899:1999 7.19.6.1(2)-undefined,ISO/IEC 9899:1999 7.19.6.1(9)-undefined,ISO/IEC 9899:2011 7.21.6.1(2)-undefined,ISO/IEC 9899:2011 7.21.6.1(9)-undefined",
        "reference": "C++ Core Guidelines SL.io.3"
        },
    "ID_this_zeroComparison": {
        "checkPoint": "不应判断 this 指针是否为空",
        "level": "warning",
        "comment": "正常情况下 this 指针不会为空，而且判断 this 指针是否为空会影响编译器对 this 指针的优化，造成难以预料的后果。",
        "tag": "pointer",
        "reference": "CWE-1025"
        },
    "ID_illMemberAccess": {
        "checkPoint": "在面向构造或析构函数体的 catch 子句中不可访问非静态成员",
        "level": "error",
        "comment": "当流程进入面向构造或析构函数体的 catch 子句时，非静态成员的生命周期已经结束，如果继续访问会导致标准未定义的行为。",
        "tag": "function",
        "standard": "ISO/IEC 14882:2003 15.3(10)-undefined,ISO/IEC 14882:2011 15.3(10)-undefined",
        "reference": "MISRA C++ 2008 15-3-3,SEI CERT ERR53-CPP"
        },
    "ID_this_selfJudgement": {
        "checkPoint": "拷贝赋值运算符应处理参数是自身对象时的情况",
        "level": "warning",
        "comment": "如果拷贝赋值运算符的参数是自身对象，需防止资源分配和回收方面的冲突。",
        "tag": "function",
        "reference": "C++ Core Guidelines C.62"
        },
    "ID_this_deleteInDestructor": {
        "checkPoint": "析构函数中不可使用 delete this",
        "level": "error",
        "comment": "析构函数中不可使用 delete this，否则造成无限递归。",
        "tag": "pointer",
        "reference": "CWE-674"
        },
    "ID_this_forbidDeleteThis": {
        "checkPoint": "禁用 delete this",
        "level": "suggestion",
        "comment": "由于限制条件易被打破，对框架以及语言工具之外的业务类或算法类代码建议禁用 delete this。",
        "tag": "pointer"
        },
    "ID_deprecatedSpecifier": {
        "checkPoint": "不应使用已过时的关键字",
        "level": "warning",
        "comment": "在 C++11 标准中，register 关键字已过时，auto 关键字也不可再作为“存储类说明符（storage class specifier）”。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2011 7.1.6.4(3),ISO/IEC 14882:2011 D.2(1)-deprecated"
        },
    "ID_inlineRedundant": {
        "checkPoint": "不应使用多余的 inline 关键字",
        "level": "suggestion",
        "comment": "由 constexpr 关键字限定的函数已经相当于被声明为 inline，不应再重复声明。",
        "standard": "ISO/IEC 14882:2003 7.1.2(3),ISO/IEC 14882:2011 7.1.2(3),ISO/IEC 14882:2011 7.1.5(2)",
        "tag": "declaration"
        },
    "ID_badName": {
        "checkPoint": "遵循合理的命名方式",
        "level": "suggestion",
        "comment": "应遵循易于读写，并可准确表达代码意图的命名方式。",
        "config": [
            "maxObjNameLength: 对象名称长度上限，超过则报出",
            "maxFunNameLength: 函数名称长度上限，超过则报出",
            "maxTypeNameLength: 类型名称长度上限，超过则报出",
            "maxWordLength: 连续无大小写变化的字符数量上限，超过则报出"
            ],
        "tag": "declaration",
        "standard": "ISO/IEC 9899:1999 5.2.4.1(1),ISO/IEC 9899:1999 6.4.2.1(6)-undefined,ISO/IEC 9899:2011 5.2.4.1(1),ISO/IEC 9899:2011 6.4.2.1(6)-undefined",
        "reference": "C++ Core Guidelines NL.19,C++ Core Guidelines ES.8,MISRA C 2004 5.1,MISRA C 2012 5.1,MISRA C 2012 5.2,MISRA C 2012 5.4,MISRA C 2012 5.5,MISRA C++ 2008 2-10-1"
        },
    "ID_reservedName": {
        "checkPoint": "不应定义具有保留意义的名称",
        "level": "suggestion",
        "comment": "自定义的名称不应与标准库或编译环境中的名称相同，否则会导致标准未定义的行为，也不利于阅读和维护。",
        "tag": "declaration",
        "related": "ID_macro_defineReserved,ID_macro_undefReserved",
        "standard": "ISO/IEC 9899:1999 7.1.3(1),ISO/IEC 9899:2011 7.1.3(1),ISO/IEC 14882:2003 17.4.3.1,ISO/IEC 14882:2011 17.6.4.3,ISO/IEC 14882:2017 20.5.4.3",
        "reference": "MISRA C 2012 21.2,MISRA C++ 2008 17-0-1,MISRA C++ 2008 17-0-2,MISRA C++ 2008 17-0-3,SEI CERT DCL37-C,SEI CERT DCL51-CPP"
        },
    "ID_duplicatedTypeName": {
        "checkPoint": "类型名称不应重复定义",
        "level": "suggestion",
        "comment": "如果类型相关的名称有重复，极易引起误解，不利于阅读和维护。",
        "tag": "declaration",
        "reference": "MISRA C 2004 5.3,MISRA C 2004 5.4,MISRA C 2012 5.6,MISRA C 2012 5.7,MISRA C++ 2008 2-10-3,MISRA C++ 2008 2-10-4"
        },
    "ID_duplicatedName": {
        "checkPoint": "类型名称不应与对象或函数名称相同",
        "level": "suggestion",
        "comment": "不同的代码元素使用相同的名称不利于阅读和维护。",
        "tag": "declaration",
        "reference": "MISRA C++ 2008 2-10-6"
        },
    "ID_misspelling": {
        "checkPoint": "不应存在拼写错误",
        "level": "suggestion",
        "comment": "代码中不应存在拼写错误，尤其是供他人调用的代码，如命名空间名称、公共接口名称等，更不应存在拼写错误。",
        "tag": "declaration"
        },
    "ID_mixNullptrAndNULL": {
        "checkPoint": "在 C++ 代码中 NULL 和 nullptr 不应混用",
        "level": "warning",
        "comment": "在 C++ 代码中 NULL 和 nullptr 不应混用，应统一使用 nullptr。",
        "tag": "style",
        "related": "ID_deprecatedNULL",
        "reference": "C++ Core Guidelines ES.47"
        },
    "ID_deprecatedNULL": {
        "checkPoint": "在 C++ 代码中用 nullptr 代替 NULL",
        "level": "suggestion",
        "comment": "标识符 NULL 由实现定义，在 C++ 语言中往往等同于常量 0，无法有效区分整数与指针，用 nullptr 可避免这种问题。",
        "tag": "style",
        "standard": "ISO/IEC 14882:2003 C.2.2.3(1)-implementation,ISO/IEC 14882:2011 2.14.7(1),ISO/IEC 14882:2011 C.3.2.4(1)-implementation,ISO/IEC 14882:2017 C.5.2.7(1)-implementation",
        "reference": "C++ Core Guidelines ES.47"
        },
    "ID_deprecatedOffsetof": {
        "checkPoint": "在 C++ 代码中不应使用宏 offsetof",
        "level": "suggestion",
        "comment": "宏 offsetof 很难适用于具有 C++ 特性的类，在 C++ 代码中不应使用。",
        "tag": "precompile",
        "standard": "ISO/IEC 14882:2003 18.1(5)-undefined,ISO/IEC 14882:2011 18.2(4)-undefined",
        "reference": "MISRA C++ 2008 18-2-1,SEI CERT EXP59-CPP"
        },
    "ID_forbidReinterpretCast": {
        "checkPoint": "合理使用 reinterpret_cast",
        "level": "suggestion",
        "comment": "reinterpret_cast 是一种不安全的类型转换，如果必须使用需提供合理的注释说明。",
        "tag": "cast",
        "related": "ID_forbidCStyleCast,ID_stricterAlignedCast",
        "reference": "CWE-843,C++ Core Guidelines Pro.safety"
        },
    "ID_sizeof_suspiciousAdd": {
        "checkPoint": "指针加减偏移量时计入 sizeof 是可疑的",
        "level": "suspicious",
        "comment": "指针加减偏移量时会自动计入指针指向类型的大小，如果再计入 sizeof 的值，很可能是某种错误。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 6.5.6(8),ISO/IEC 9899:2011 6.5.6(8)",
        "reference": "CWE-468"
        },
    "ID_insufficientBuffer": {
        "checkPoint": "为缓冲区分配足够的空间",
        "level": "warning",
        "comment": "为缓冲区分配足够的空间，避免溢出等问题。",
        "tag": "buffer",
        "related": "ID_bufferOverflow",
        "reference": "CWE-131,CWE-135"
        },
    "ID_assignmentAsSubExpression": {
        "checkPoint": "赋值表达式不应作为子表达式",
        "level": "suggestion",
        "comment": "赋值及复合赋值表达式作为子表达式可读性较差，易产生求值顺序或运算符优先级相关的问题。",
        "config": [
            "allowSuccessiveAssignment: 是否允许连续赋值"
            ],
        "tag": "style",
        "related": "ID_if_assignment",
        "reference": "CWE-481,MISRA C 2004 13.1,MISRA C 2012 13.4,MISRA C++ 2008 6-2-1"
        },
    "ID_incDecAsSubExpression": {
        "checkPoint": "自增、自减表达式不应作为子表达式",
        "level": "suggestion",
        "comment": "自增、自减表达式作为子表达式易使人费解，也易产生求值顺序相关的问题。",
        "tag": "style",
        "related": "ID_evaluationOrderReliance",
        "reference": "MISRA C 2012 13.3,MISRA C++ 2008 5-2-10"
        },
    "ID_nonBoolCondition": {
        "checkPoint": "控制条件应为 bool 型表达式",
        "level": "suggestion",
        "comment": "如果控制条件均为 bool 型表达式，可使逻辑结构更清晰，有效避免隐式类型转换造成的问题。",
        "tag": "style",
        "related": "ID_nonBoolSubCondition",
        "reference": "MISRA C 2012 14.4,MISRA C++ 2008 5-0-13,MISRA C++ 2008 5-0-14"
        },
    "ID_nonBoolSubCondition": {
        "checkPoint": "!、&&、|| 的子表达式应为 bool 型表达式",
        "level": "suggestion",
        "comment": "如果 !、&&、|| 的子表达式均为 bool 型表达式，可使逻辑结构更清晰，有效避免隐式类型转换或运算符误用造成的问题。",
        "tag": "style",
        "related": "ID_nonBoolCondition,ID_illBoolOperation",
        "reference": "MISRA C++ 2008 5-3-1"
        },
    "ID_nonPostfixSubCondition": {
        "checkPoint": "&&、|| 的子表达式应为后缀表达式",
        "level": "suggestion",
        "comment": "如果 &&、|| 的子表达式均为后缀表达式，可使逻辑结构更清晰，有效避免各种优先级问题。",
        "tag": "style",
        "standard": "ISO/IEC 9899:1999 6.5.2(1),ISO/IEC 9899:2011 6.5.2(1),ISO/IEC 14882:2003 5.2(1),ISO/IEC 14882:2011 5.2(1)",
        "reference": "MISRA C++ 2008 5-2-1"
        },
    "ID_secretLeak": {
        "checkPoint": "敏感数据不可被系统外界感知",
        "level": "warning",
        "comment": "敏感数据出入软件系统时需采用有效的保护措施。",
        "tag": "security",
        "related": "ID_unsafeCleanup",
        "reference": "CWE-528,CWE-591,SEI CERT MEM06-C"
        },
    "ID_unsafeCleanup": {
        "checkPoint": "敏感数据在使用后应被有效清理",
        "level": "warning",
        "comment": "及时清理不再使用的敏感数据是重要的安全措施，且应保证清理过程不会因为编译器的优化而失效。",
        "tag": "security",
        "standard": "ISO/IEC 9899:1999 5.1.2.3(3),ISO/IEC 9899:2011 5.1.2.3(4),ISO/IEC 9899:2011 K.3.7.4.1",
        "related": "ID_secretLeak,ID_ignorePaddingData",
        "reference": "CWE-14,CWE-226,CWE-244,CWE-733,SEI CERT MSC06-C"
        },
    "ID_nonConstNonStaticGlobalObject": {
        "checkPoint": "全局对象只应为常量或静态对象",
        "level": "warning",
        "comment": "非常量全局对象破坏了面向对象的封装理念，如果必须使用全局对象，应将其限定在文件范围之内。",
        "tag": "global",
        "related": "ID_nonConstGlobalObject",
        "reference": "C++ Core Guidelines I.2,C++ Core Guidelines CP.3,C++ Core Guidelines R.6"
        },
    "ID_nonConstGlobalObject": {
        "checkPoint": "全局对象只应为常量",
        "level": "warning",
        "comment": "非常量全局对象对外部的读写没有限制，破坏了面向对象的封装理念，不利于维护。",
        "tag": "global",
        "config": [
            "onlyConstBasicTypeAllowed: 是否只允许基本类型的常量作为全局对象"
            ],
        "related": "ID_nonPrivateData,ID_relyOnExternalObject",
        "reference": "C++ Core Guidelines I.2,C++ Core Guidelines CP.3,C++ Core Guidelines R.6"
        },
    "ID_forbidMemberVoidPtr": {
        "checkPoint": "类成员的类型不应为 void*",
        "level": "warning",
        "comment": "与接口相关的数据类型应保持精确，不应将成员类型设为 void*，尤其是非 private 成员的类型，更不应设为 void*。",
        "tag": "declaration",
        "related": "ID_voidCast,ID_forbidFunctionVoidPtr",
        "reference": "C++ Core Guidelines I.4"
        },
    "ID_forbidFunctionVoidPtr": {
        "checkPoint": "接口的参数类型和返回类型不应为 void*",
        "level": "warning",
        "comment": "与接口相关的数据类型应保持精确，不应将参数类型或返回类型设为 void*。",
        "tag": "declaration",
        "related": "ID_voidCast,ID_forbidMemberVoidPtr",
        "reference": "C++ Core Guidelines I.4"
        },
    "ID_improperNullTermination": {
        "checkPoint": "确保字符串以空字符结尾",
        "level": "warning",
        "comment": "语言要求字符串以空字符结尾，程序应保证有足够的内存空间安置空字符，否则会破坏程序基本的执行机制，造成严重问题。",
        "tag": "security",
        "standard": "ISO/IEC 9899:1999 7.21.2.4,ISO/IEC 9899:2011 7.24.2.4",
        "related": "ID_unsafeStringFunction",
        "reference": "CWE-170"
        },
    "ID_deprecatedErrno":  {
        "checkPoint": "选择安全的异常处理方式",
        "level": "warning",
        "comment": "避免使用 errno 和与其相同的模式，应根据实际需求选择通过函数返回值或 C++ 异常机制来处理异常情况。",
        "tag": "security",
        "reference": "C++ Core Guidelines E.28,MISRA C 2004 20.5,MISRA C++ 2008 19-3-1"
    },
    "ID_unsafeStringFunction": {
        "checkPoint": "禁用不安全的字符串函数",
        "level": "warning",
        "comment": "由于历史原因，C 标准库中的某些字符串函数不执行边界检查，易造成运行时错误和安全漏洞。",
        "tag": "security",
        "standard": "ISO/IEC 9899:2011 Annex K,ISO/IEC 9899:2011 K.3.7,ISO/IEC 9899:2011 K.3.9",
        "related": "ID_bufferOverflow",
        "reference": "CWE-119,CWE-120,CWE-676,MISRA C++ 2008 18-0-5"
        },
    "ID_forbidAtox": {
        "checkPoint": "禁用 atof、atoi、atol 以及 atoll 等函数",
        "level": "warning",
        "comment": "当字符串无法被正确转为数值时，stdlib.h 或 cstdlib 中的 atof、atoi、atol 以及 atoll 等函数会导致标准未定义的行为。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:1999 7.20.1(1)-undefined,ISO/IEC 9899:2011 7.22.1(1)-undefined",
        "reference": "MISRA C 2004 20.10,MISRA C 2012 21.7,MISRA C++ 2008 18-0-2"
        },
    "ID_forbidLongjmp": {
        "checkPoint": "禁用 setjmp、longjmp",
        "level": "warning",
        "comment": "setjmp、longjmp 可以在函数间跳转，进一步破坏了结构化编程理念，非框架代码不应使用。",
        "tag": "control",
        "standard": "ISO/IEC 9899:1999 7.13.2.1(2)-undefined,ISO/IEC 14882:2011 18.10(4)-undefined",
        "reference": "C++ Core Guidelines SL.C.1,MISRA C 2004 20.7,MISRA C 2012 21.4,MISRA C++ 2008 17-0-5,SEI CERT ERR52-CPP"
        },
    "ID_obsoleteFunction": {
        "checkPoint": "避免使用已过时的接口",
        "level": "warning",
        "comment": "避免使用在相关标准中已过时的接口，应改用更完善的替代方法以规避风险，提高可移植性。",
        "tag": "security",
        "related": "ID_obsoleteStdFunction",
        "reference": "CWE-477"
        },
    "ID_dangerousFunction": {
        "checkPoint": "避免使用危险接口",
        "level": "warning",
        "comment": "由于历史原因，有些系统接口甚至标准库函数存在缺陷，无法安全使用，也有一些接口的使用条件很苛刻，难以安全使用。",
        "tag": "security",
        "reference": "CWE-242,CWE-676"
        },
    "ID_implementationDefinedFunction": {
        "checkPoint": "避免使用由实现定义的库函数",
        "level": "warning",
        "comment": "由实现定义的（implementation-defined）库函数会增加移植或兼容等方面的成本。",
        "tag": "expression",
        "standard": "ISO/IEC 9899:2011 7.14.1.1(3)-implementation,ISO/IEC 9899:2011 7.22.4.1(2)-implementation,ISO/IEC 9899:2011 7.22.4.4(5)-implementation,ISO/IEC 9899:2011 7.22.4.5(2)-implementation,ISO/IEC 9899:2011 7.22.4.6(2)-implementation,ISO/IEC 9899:2011 7.22.4.7(4)-implementation,ISO/IEC 9899:2011 7.22.4.8(3)-implementation,ISO/IEC 9899:2011 7.27.2.1(3)-implementation",
        "reference": "CWE-474,CWE-589,MISRA C 2004 20.8,MISRA C 2004 20.11,MISRA C 2004 20.12,MISRA C 2012 21.5,MISRA C 2012 21.8,MISRA C 2012 21.10,MISRA C++ 2008 18-0-3,MISRA C++ 2008 18-0-4,MISRA C++ 2008 18-7-1"
        },
    "ID_missingVoid": {
        "checkPoint": "C 代码中参数列表如果为空应声明为“(void)”",
        "level": "warning",
        "comment": "在 C 语言中，如果函数的参数列表声明为空括号，表示函数的参数还没有声明，而不是表示没有参数，这很容易使人误解，所以在 C 代码中没有参数的参数列表应声明为“(void)”。",
        "tag": "declaration",
        "related": "ID_superfluousVoid",
        "standard": "ISO/IEC 9899:1999 6.7.5.3(14),ISO/IEC 9899:1999 6.11.6(1),ISO/IEC 9899:2011 6.7.6.3(14),ISO/IEC 9899:2011 6.11.6(1)",
        "reference": "MISRA C 2004 16.5"
        },
    "ID_superfluousVoid": {
        "checkPoint": "C++ 代码中参数列表如果为空不应声明为“(void)”",
        "level": "suggestion",
        "comment": "与 C 语言不同，在 C++ 语言中空括号和“(void)”均表示没有参数，所以应采用更简洁的方式。",
        "tag": "declaration",
        "related": "ID_missingVoid",
        "standard": "ISO/IEC 14882:2003 C.1.6 Clause 8,ISO/IEC 14882:2011 C.1.7 Clause 8,ISO/IEC 14882:2017 C.1.7 Clause 11",
        "reference": "C++ Core Guidelines NL.25"
        },
    "ID_missingResetNull": {
        "checkPoint": "指针在释放后应置空",
        "level": "suggestion",
        "comment": "内存空间被回收后相关指针不再有效，这时应将指针设为空指针，可避免重复释放等问题，如果后续对指针有错误访问，也可使问题立即显现出来，便于修正。",
        "tag": "pointer",
        "related": "ID_danglingDeref,ID_explicitDtorCall",
        "reference": "SEI CERT MEM01-C"
        },
    "ID_unlimitedAuthority": {
        "checkPoint": "对资源设定合理的访问权限",
        "level": "warning",
        "comment": "对资源设定合理的访问权限，避免为攻击者提供不应拥有的权限或能力。",
        "tag": "security",
        "standard": "ISO/IEC 9899:2011 K.3.5.2.1(7),ISO/IEC 14882:2017 30.10.15.26",
        "reference": "CWE-266,CWE-732,SEI CERT FIO06-C"
        },
    "ID_dataRaces": {
        "checkPoint": "访问共享数据应遵循合理的同步机制",
        "level": "warning",
        "comment": "如果一份数据同时被多个线程、进程或中断处理过程读写，会产生不确定的结果，这种情况称为“数据竞争（data race）”，会导致标准未定义的行为，应落实合理的同步机制来控制访问共享数据的先后顺序。",
        "tag": "concurrency",
        "standard": "ISO/IEC 9899:2011 5.1.2.4(3)-undefined,ISO/IEC 9899:2011 5.1.2.4(20)-undefined,ISO/IEC 9899:2011 5.1.2.4(25)-undefined",
        "related": "ID_sig_dataRaces,ID_sig_nonAsyncSafeCall",
        "reference": "CWE-362,C++ Core Guidelines CP.2,SEI CERT CON33-C,SEI CERT CON43-C"
        },
    "ID_TOCTOU": {
        "checkPoint": "避免在事务中通过路径多次访问同一文件",
        "level": "warning",
        "comment": "攻击者可以在两次通过路径访问文件的中途对文件做手脚，从而造成不良后果。",
        "tag": "concurrency",
        "standard": "ISO/IEC 9899:1999 7.19.5.3(3),ISO/IEC 9899:2011 7.21.5.3(3)",
        "reference": "CWE-367"
        },
    "ID_hijack": {
        "checkPoint": "预判用户输入造成的不良后果",
        "level": "warning",
        "comment": "须对用户输入的脚本、路径、资源请求等信息进行预判，对产生不良后果的输入予以拒绝。",
        "tag": "security",
        "reference": "CWE-23,CWE-73,CWE-89,CWE-943"
        },
    "ID_bufferOverflow": {
        "checkPoint": "避免缓冲区溢出",
        "level": "warning",
        "comment": "对缓冲区的读写应在有效边界内进行。",
        "tag": "buffer",
        "related": "ID_arrayIndexOverflow,ID_unsafeStringFunction",
        "reference": "CWE-119,CWE-125,CWE-787,CWE-788"
        },
    "ID_protectedData": {
        "checkPoint": "类的非常量数据成员不应定义为 protected",
        "level": "suggestion",
        "comment": "protected 数据成员在派生类中仍可被随意读写，破坏了封装理念。",
        "tag": "type",
        "related": "ID_mixPublicPrivateData,ID_nonPrivateData",
        "reference": "C++ Core Guidelines C.9,C++ Core Guidelines C.133"
        },
    "ID_mixPublicPrivateData": {
        "checkPoint": "类不应既有 public 数据成员又有 private 数据成员",
        "level": "suggestion",
        "comment": "类不应既有 public 数据成员又有 private 数据成员。",
        "tag": "type",
        "related": "ID_nonPrivateData,ID_protectedData",
        "reference": "C++ Core Guidelines C.9,C++ Core Guidelines C.134"
        },
    "ID_returnRValueReference": {
        "checkPoint": "函数返回值不应为右值引用",
        "level": "suggestion",
        "comment": "函数返回右值引用的实际价值有限，且易产生错误。",
        "tag": "function",
        "related": "ID_localAddressFlowOut",
        "reference": "C++ Core Guidelines F.45"
        },
    "ID_returnConstObject": {
        "checkPoint": "函数返回值不应为常量对象",
        "level": "suggestion",
        "comment": "函数返回常量对象不利于移动构造或移动赋值等机制，也可能本意是返回引用，但遗漏了引用符号。",
        "tag": "function",
        "related": "ID_returnSuperfluousConst",
        "reference": "C++ Core Guidelines F.20"
        },
    "ID_nonPrivateData": {
        "checkPoint": "类的非常量数据成员均应为 private",
        "level": "suggestion",
        "comment": "类的数据成员均应设为 private，对外统一由成员函数提供访问方法，且应避免返回 private 成员的非常量引用或指针。",
        "tag": "type",
        "related": "ID_protectedData,ID_mixPublicPrivateData",
        "reference": "MISRA C++ 2008 11-0-1"
        },
    "ID_unsuitableStructTag": {
        "checkPoint": "存在构造、析构或虚函数的类不应采用 struct 关键字",
        "level": "suggestion",
        "comment": "简单结构体应采用 struct 关键字，具有封装或多态等特性的类应采用 class 关键字，以便提高可读性。",
        "tag": "type",
        "reference": "C++ Core Guidelines C.2,C++ Core Guidelines C.8"
        },
    "ID_improperAuthorization": {
        "checkPoint": "对用户落实有效的权限管理",
        "level": "warning",
        "comment": "权限管理与产品安全直接相关，应落实严格的评审、测试以及攻防演练。",
        "tag": "security",
        "reference": "CWE-285,CWE-350"
        },
    "ID_redundantSemicolon": {
        "checkPoint": "避免多余的分号",
        "level": "suggestion",
        "comment": "多余的分号使代码显得繁琐，也可能意味着某种错误，应去掉。",
        "tag": "style"
        },
    "ID_specialComment": {
        "checkPoint": "关注 TODO、FIXME、XXX、BUG 等特殊注释",
        "level": "warning",
        "comment": "TODO、FIXME、XXX、BUG 等特殊注释表示代码中存在问题，这种问题不应被遗忘，应有计划地予以解决。",
        "tag": "precompile",
        "config":  [
            "specialCommentPatterns: 特殊注释的模式字符串（如正则表达式等），供审计工具查找"
            ],
        "reference": "CWE-546"
        },
    "ID_nestedComment": {
        "checkPoint": "注释不可嵌套",
        "level": "warning",
        "comment": "嵌套的 /*...*/ 注释不符合标准，/* 与 */ 之间不应出现 /*，某些编译器可以接受嵌套，但不具备可移植性。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.4.9(1),ISO/IEC 9899:2011 6.4.9(1)",
        "reference": "MISRA C 2004 2.3,MISRA C 2012 3.1,MISRA C++ 2008 2-7-1"
        },
    "ID_badCommentPosition": {
        "checkPoint": "注释应出现在合理的位置",
        "level": "suggestion",
        "comment": "注释应出现在段落的前后或行尾，不应出现在行首或中间，否则干扰阅读，甚至会导致标准未定义的行为。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.4.7(3)-undefined,ISO/IEC 9899:2011 6.4.7(3)-undefined,ISO/IEC 14882:2003 2.8(2)-undefined,ISO/IEC 14882:2011 2.9(2)-implementation"
        },
    "ID_badBackslash": {
        "checkPoint": "除转义字符、宏定义之外不应使用反斜杠",
        "level": "warning",
        "comment": "反斜杠可用于标识转义字符，也可用于实现“伪换行”，即代码换行显示但在语法上并没有换行，一般用于宏定义，除此之外不应再使用反斜杠，否则没有实际意义，也会造成混乱。",
        "tag": "precompile",
        "standard": "ISO/IEC 14882:2003 2.1(1)-undefined,ISO/IEC 14882:2011 2.2(1)-undefined",
        "reference": "MISRA C 2012 3.2"
        },
    "ID_deleteIncompleteType": {
        "checkPoint": "用 delete 释放对象需保证其类型完整",
        "level": "warning",
        "comment": "如果用 delete 释放不完整类型的对象，而对象完整类型声明中有 non-trivial 析构函数，会导致标准未定义的行为。",
        "tag": "resource",
        "standard": "ISO/IEC 14882:2003 5.3.5(5)-undefined,ISO/IEC 14882:2011 5.3.5(5)-undefined"
        },
    "ID_missingNewLineFileEnd": {
        "checkPoint": "非空源文件应以换行符结尾",
        "level": "suggestion",
        "comment": "如果非空源文件未以换行符结尾，或以换行符结尾但换行符之前是反斜杠，在 C 和 C++03 标准中会导致未定义的行为。",
        "tag": "precompile",
        "config": [
            "allTxtFileNeedNewLineEnd: 是否要求所有文本文件均以换行符结尾"
            ],
        "standard": "ISO/IEC 9899:1999 5.1.1.2(1)-undefined,ISO/IEC 9899:2011 5.1.1.2(1)-undefined,ISO/IEC 14882:2003 2.1(1)-undefined,ISO/IEC 14882:2011 2.2(1)"
        },
    "ID_directiveInMacroArgument": {
        "checkPoint": "宏的参数列表中不应出现预编译指令",
        "level": "warning",
        "comment": "如果预编译指令出现在宏的参数列表中，会导致标准未定义的行为。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.10.3(11)-undefined,ISO/IEC 9899:2011 6.10.3(11)-undefined,ISO/IEC 14882:2003 16.3(10)-undefined,ISO/IEC 14882:2011 16.3(11)-undefined",
        "reference": "MISRA C 2012 20.6,MISRA C++ 2008 16-0-5"
        },
    "ID_violateODR": {
        "checkPoint": "遵循 One Definition Rule",
        "level": "warning",
        "comment": "One Definition Rule 即任何翻译单元不得包含对象、函数、类型或模板的多个定义，否则会导致标准未定义的行为。",
        "tag": "declaration",
        "standard": "ISO/IEC 14882:2003 3.2(5)-undefined,ISO/IEC 14882:2011 3.2(5)-undefined",
        "reference": "MISRA C++ 2008 3-2-2"
        },
    "ID_badParmN": {
        "checkPoint": "parmN 的声明应符合要求",
        "level": "error",
        "comment": "parmN 是可变参数列表中省略号的前一个参数，该参数不符合要求会导致标准未定义的行为。",
        "tag": "declaration",
        "related": "ID_badVaArgType,ID_forbidVariadicFunction",
        "standard": "ISO/IEC 9899:1999 7.15.1.4(4)-undefined,ISO/IEC 9899:2011 7.16.1.4(4)-undefined,ISO/IEC 14882:2003 18.7(3)-undefined,ISO/IEC 14882:2011 18.10(3)-undefined",
        "reference": "SEI CERT EXP58-CPP"
        },
    "ID_badVaArgType": {
        "checkPoint": "va_arg 的类型参数应符合要求",
        "level": "error",
        "comment": "如果 va_arg 的类型参数不符合要求，会导致标准未定义的行为。",
        "tag": "precompile",
        "related": "ID_badParmN,ID_nonPODVariadicArgument,ID_forbidVariadicFunction",
        "standard": "ISO/IEC 9899:1999 7.15.1.1(2)-undefined,ISO/IEC 9899:2011 7.16.1.1(2)-undefined",
        "reference": "SEI CERT EXP47-C"
        },
    "ID_voidCast": {
        "checkPoint": "避免与 void* 相互转换",
        "level": "suggestion",
        "comment": "与 void* 相互转换会打破类型限制，是不安全的类型转换。",
        "tag": "cast",
        "related": "ID_forbidMemberVoidPtr,ID_forbidFunctionVoidPtr",
        "standard": "ISO/IEC 14882:2003 5.2.10(7)-unspecified,ISO/IEC 14882:2011 5.2.10(7)-unspecified",
        "reference": "MISRA C 2012 11.5,MISRA C 2012 11.6,MISRA C++ 2008 5-2-8"
        },
    "ID_sig_dataRaces": {
        "checkPoint": "避免由信号处理产生的数据竞争",
        "level": "warning",
        "comment": "避免由信号处理产生的数据竞争。",
        "tag": "interruption",
        "standard": "ISO/IEC 9899:1999 7.14.1.1(5)-undefined,ISO/IEC 9899:2011 7.14.1.1(5)-undefined,ISO/IEC 14882:2003 1.9(9)-undefined,ISO/IEC 14882:2011 1.9(6)-undefined",
        "related": "ID_dataRaces,ID_sig_nonAsyncSafeCall",
        "reference": "SEI CERT SIG31-C"
        },
    "ID_sig_nonAsyncSafeCall": {
        "checkPoint": "处理信号时避免使用非异步信号安全函数",
        "level": "warning",
        "comment": "不处理共享数据也不会影响程序状态的函数，以及不会被信号中断的函数称为“异步信号安全”函数，处理信号时只应使用这种函数。",
        "tag": "interruption",
        "standard": "ISO/IEC 9899:1999 7.14.1.1(5)-undefined,ISO/IEC 9899:2011 7.14.1.1(5)-undefined",
        "related": "ID_sig_dataRaces,ID_dataRaces",
        "reference": "SEI CERT SIG30-C"
        },
    "ID_sig_illReturn": {
        "checkPoint": "SIGFPE、SIGILL、SIGSEGV 等信号的处理函数不可返回",
        "level": "warning",
        "comment": "与计算异常相关的信号由不可恢复的错误引起，相关信号处理函数应终止程序的执行，否则导致标准未定义的行为。",
        "tag": "interruption",
        "standard": "ISO/IEC 9899:1999 7.14.1.1(3)-undefined,ISO/IEC 9899:2011 7.14.1.1(3)-undefined",
        "reference": "SEI CERT SIG35-C"
        },
    "ID_forbidSignalFunction": {
        "checkPoint": "禁用 signal 函数",
        "level": "suggestion",
        "comment": "signal 函数具有一定的局限性，且各平台实现差异较大，可用 sigaction 函数代替。",
        "tag": "interruption",
        "standard": "ISO/IEC 9899:1999 7.14.1.1(3)-implementation,ISO/IEC 9899:2011 7.14.1.1(3)-implementation,ISO/IEC 9899:2011 7.14.1.1(7)-undefined",
        "related": "ID_signalInMultiThreading,ID_implementationDefinedFunction",
        "reference": "MISRA C 2012 21.5,MISRA C++ 2008 18-7-1,SEI CERT SIG01-C,SEI CERT SIG34-C"
        },
    "ID_deadlock": {
        "checkPoint": "避免死锁",
        "level": "warning",
        "comment": "对于锁等资源，错误的请求时序或管理方式会使程序永远陷入等待状态，这种问题称为“死锁（deadlock）”。",
        "tag": "concurrency",
        "standard": "ISO/IEC 9899:2011 7.26.4.3(2)-undefined,ISO/IEC 14882:2011 17.3.8",
        "reference": "SEI CERT CON35-C,SEI CERT CON53-CPP,SEI CERT CON56-CPP"
        },
    "ID_illLifetime": {
        "checkPoint": "避免异步终止共享对象的生命周期",
        "level": "warning",
        "comment": "共享对象的使用情况在异步过程中是难以掌控的，贸然终止共享对象的生命周期往往会导致标准未定义的行为。",
        "tag": "concurrency",
        "standard": "ISO/IEC 14882:2011 30.4.1.2.1(5)-undefined,ISO/IEC 14882:2017 33.4.3.2.1(5)-undefined",
        "related": "ID_asynchronousTermination,ID_localAddressFlowOut,ID_danglingDeref",
        "reference": "SEI CERT CON31-C,SEI CERT CON50-CPP"
        },
    "ID_asynchronousTermination": {
        "checkPoint": "避免异步终止线程",
        "level": "warning",
        "comment": "资源的使用情况在异步过程中是难以掌控的，异步终止线程往往会导致泄漏或死锁等严重问题。",
        "tag": "concurrency",
        "related": "ID_resourceLeak,ID_deadlock,ID_illLifetime",
        "reference": "SEI CERT POS47-C"
        },
    "ID_spuriouslyWakeUp": {
        "checkPoint": "避免虚假唤醒造成同步错误",
        "level": "warning",
        "comment": "条件不满足时条件变量也可以被唤醒，这种情况称为“虚假唤醒（spurious wakeup）”，条件变量被唤醒后应检查相关条件是否满足，否则会造成同步相关的错误。",
        "tag": "concurrency",
        "reference": "SEI CERT CON36-C,SEI CERT CON54-CPP"
        },
    "ID_bitfieldDataRaces": {
        "checkPoint": "避免并发访问位域造成的数据竞争",
        "level": "warning",
        "comment": "相邻的位域成员可能在一个存储单元中，所以并发访问位域也可能造成数据竞争。",
        "tag": "concurrency",
        "related": "ID_dataRaces,ID_forbidBitfield",
        "standard": "ISO/IEC 9899:2011 3.14(3),ISO/IEC 14882:2011 1.7(4)",
        "reference": "SEI CERT CON32-C,SEI CERT CON52-CPP"
        },
    "ID_signalInMultiThreading": {
        "checkPoint": "多线程环境中不可使用 signal 函数",
        "level": "warning",
        "comment": "在多线程环境中使用 signal 函数会导致标准未定义的行为。",
        "tag": "concurrency",
        "standard": "ISO/IEC 9899:2011 7.14.1.1(7)-undefined",
        "related": "ID_forbidSignalFunction",
        "reference": "SEI CERT CON37-C"
        },
    "ID_stricterAlignedCast": {
        "checkPoint": "避免向对齐要求更严格的指针转换",
        "level": "warning",
        "comment": "访问不符合对齐要求的数据会导致标准未定义的行为。",
        "tag": "cast",
        "standard": "ISO/IEC 9899:1999 6.3.2.3(7)-undefined,ISO/IEC 9899:2011 6.3.2.3(7)-undefined",
        "related": "ID_castNoInheritance",
        "reference": "SEI CERT EXP36-C"
        },
    "ID_ignorePaddingData": {
        "checkPoint": "数据成员之间的填充数据不应被忽视",
        "level": "warning",
        "comment": "成员之间存在填充数据，且没有声明对齐方式时，填充数据的长度是由实现定义的，这种数据不应在不同的环境之间传输，而且应注意成员的声明顺序，避免由填充数据造成的空间浪费。",
        "tag": "type",
        "related": "ID_accessPaddingData",
        "standard": "ISO/IEC 9899:2011 6.2.8(1)-implementation,ISO/IEC 14882:2011 3.11(1)-implementation",
        "reference": "SEI CERT DCL39-C"
        },
    "ID_atomicRaces": {
        "checkPoint": "避免在事务中多次非同步地访问原子对象",
        "level": "warning",
        "comment": "原子对象可以保证某些特定操作的原子性，但特定操作的组合并不具备原子性，非同步地访问原子对象仍然存在数据竞争。",
        "tag": "concurrency",
        "related": "ID_dataRaces",
        "reference": "SEI CERT CON40-C"
        },
    "ID_missingHardening": {
        "checkPoint": "启用平台和编译器提供的防御机制",
        "level": "suggestion",
        "comment": "针对一些常见攻击，平台和编译器会提供防御机制，程序应利用这种机制加强自身的安全性。",
        "tag": "security"
        },
    "ID_exitHandlerNoReturn": {
        "checkPoint": "由 atexit、at_quick_exit 指定的处理函数应正常返回",
        "level": "warning",
        "comment": "如果 atexit、at_quick_exit 指定的处理函数未正常返回，会导致标准未定义的行为。",
        "tag": "function",
        "standard": "ISO/IEC 9899:1999 7.20.4.3(2 3)-undefined,ISO/IEC 9899:2011 7.22.4.4(2 3)-undefined",
        "reference": "SEI CERT ENV32-C"
        },
    "ID_nonConstUnmodified": {
        "checkPoint": "相关对象未被修改时应使用 const 声明",
        "level": "suggestion",
        "comment": "用 const 显式区分数据是只读的还是可写的，细化数据的访问方式可显著提高可读性，并保护数据不被错误修改，有助于编译器优化。",
        "tag": "declaration",
        "related": "ID_constStrToNonConstPtr",
        "reference": "C++ Core Guidelines Con.1,C++ Core Guidelines Con.2,C++ Core Guidelines Con.3,C++ Core Guidelines Con.4,MISRA C 2012 18.3,MISRA C++ 2008 7-1-1,MISRA C++ 2008 7-1-2"
        },
    "ID_macro_redefined": {
        "checkPoint": "宏不应被重定义",
        "level": "warning",
        "comment": "宏不受作用域限制，重定义宏会使同一个全局名称产生多种不同的意义，易导致错误并降低可维护性。",
        "tag": "precompile",
        "standard": "ISO/IEC 9899:1999 6.10.3(2),ISO/IEC 9899:2011 6.10.3(2),ISO/IEC 14882:2003 16.3(2 3),ISO/IEC 14882:2011 16.3(2)"
        },
    "ID_missingType": {
        "checkPoint": "不应省略声明对象或函数的类型",
        "level": "warning",
        "comment": "C90 允许省略对象或函数的类型声明，但实践表明这并不是一种良好的编程方式，可读性较差。",
        "tag": "declaration",
        "reference": "MISRA C 2004 8.2,MISRA C 2012 8.1"
        },
    "ID_missingArraySize": {
        "checkPoint": "数组大小应被显式声明",
        "level": "suggestion",
        "comment": "显式声明数组大小有利于提高可读性。",
        "tag": "declaration",
        "config": [
            "allowNoArraySizeWithInitList: 是否放过带有初始化列表的数组"
            ],
        "reference": "MISRA C 2004 8.12,MISRA C 2012 8.11,MISRA C++ 2008 3-1-3"
        },
    "ID_unportableType": {
        "checkPoint": "用 stdint.h 中的类型代替 short、int、long 等类型",
        "level": "suggestion",
        "comment": "short、int、long 等类型的取值范围由执行环境的架构决定，可移植性较差。",
        "tag": "declaration",
        "standard": "ISO/IEC 9899:2011 6.2.5(5),ISO/IEC 9899:2011 7.20,ISO/IEC 14882:2011 3.9.1(2)",
        "reference": "MISRA C 2004 6.3,MISRA C 2012 Dir 4.6"
        },
    "ID_jumpOutLoop": {
        "checkPoint": "避免使用跳转语句退出循环",
        "level": "suggestion",
        "comment": "循环的退出条件应与其控制表达式一致，使代码具有清晰的静态结构，否则可读性较差，尤其在多个嵌套的作用域中使用 break、goto 或 return 等跳转语句，会使代码难以理解。",
        "tag": "control",
        "related": "ID_tooManyExit",
        "reference": "MISRA C 2004 14.6,MISRA C 2012 15.4,MISRA C++ 2008 6-6-4"
        },
    "ID_tooManyExit": {
        "checkPoint": "函数的退出点数量应在规定范围之内",
        "level": "suggestion",
        "comment": "理想情况下应在函数的结尾设置统一的退出点，使代码具有清晰的静态结构，否则可读性较差，尤其在多个嵌套的作用域中使用 return 等语句，会使代码难以理解。",
        "tag": "function",
        "config": [
            "maxExitCount: 退出点数量上限，超过则报出"
            ],
        "related": "ID_jumpOutLoop",
        "reference": "MISRA C 2004 14.7,MISRA C 2012 15.5,MISRA C++ 2008 6-6-5"
        },
    "ID_inconsistentDeclaration": {
        "checkPoint": "声明与实现应一致",
        "level": "suggestion",
        "comment": "声明与实现在书写上应完全一致，否则极易引起误解，而且对同一对象或函数进行类型不兼容的声明，也会导致标准未定义的行为。",
        "tag": "declaration",
        "related": "ID_inconsistentParamName",
        "standard": "ISO/IEC 9899:1999 6.2.7(2)-undefined,ISO/IEC 9899:2011 6.2.7(2)-undefined",
        "reference": "MISRA C 2004 8.4,MISRA C 2012 8.3,MISRA C++ 2008 3-9-1,SEI CERT DCL40-C"
        },
    "ID_unsuitableDeclaration": {
        "checkPoint": "在合理的位置声明",
        "level": "suggestion",
        "comment": "如果声明的位置不合理会降低代码的可维护性，甚至会导致标准未定义的行为。",
        "tag": "declaration",
        "related": "ID_staticInHeader,ID_anonymousNamespaceInHeader",
        "standard": "ISO/IEC 9899:1999 6.7.1(5)-undefined,ISO/IEC 9899:2011 6.7.1(7)-undefined",
        "reference": "MISRA C++ 2008 3-1-2,MISRA C++ 2008 3-3-1"
        },
    "ID_missingStatic": {
        "checkPoint": "声明和定义内部链接的对象和函数时均应使用 static 关键字",
        "level": "suggestion",
        "comment": "声明和定义内部链接的对象和函数时均应使用 static 关键字，不可使用 extern 关键字，否则极易引起误解。",
        "tag": "declaration",
        "reference": "MISRA C 2004 8.11,MISRA C 2012 8.8,MISRA C++ 2008 3-3-2"
        },
    "ID_this_notUsed": {
        "checkPoint": "未访问 this 指针的成员函数应使用 static 声明",
        "level": "suggestion",
        "comment": "如果未访问 this 指针的成员函数没有被设计为静态成员函数，很可能意味着错误或功能不完整。",
        "tag": "declaration",
        "reference": "MISRA C++ 2008 9-3-3"
        },
    "ID_mixedAsm": {
        "checkPoint": "汇编代码不应与普通代码混合",
        "level": "suggestion",
        "comment": "汇编代码的格式由实现定义，不具备可移植性，且可读性较差，故不应与普通代码混合。",
        "tag": "function",
        "standard": "ISO/IEC 9899:1999 J.5.10-implementation,ISO/IEC 9899:2011 J.5.10-implementation,ISO/IEC 14882:2003 7.4(1)-implementation,ISO/IEC 14882:2011 7.4(1)-implementation",
        "reference": "MISRA C 2004 2.1,MISRA C 2012 Dir 4.3,MISRA C++ 2008 7-4-3"
        },
    "ID_macro_inBlock": {
        "checkPoint": "只应在全局作用域中定义宏",
        "level": "suggestion",
        "comment": "宏不受作用域限制，在非全局作用域中定义宏易引起误解。",
        "tag": "precompile",
        "config": [
            "allowDefineAndUndefInSameBlock: 是否允许在同一非全局作用域内定义并取消定义宏"
            ],
        "related": "ID_macro_undef",
        "standard": "ISO/IEC 9899:1999 6.10.3.5(1),ISO/IEC 9899:2011 6.10.3.5(1)",
        "reference": "MISRA C 2004 19.5,MISRA C++ 2008 16-0-2"
        },
    "ID_macro_undef": {
        "checkPoint": "避免宏被取消定义",
        "level": "suggestion",
        "comment": "宏不受作用域限制，不应被取消定义，否则会失去确定性，使代码难以维护。",
        "tag": "precompile",
        "config": [
            "allowUndefMacroInSameBlock: 是否允许取消在同一作用域内定义的宏"
            ],
        "related": "ID_macro_undefReserved,ID_macro_inBlock",
        "reference": "MISRA C 2004 19.6,MISRA C 2012 20.5,MISRA C++ 2008 16-0-3"
        },
    "ID_incompleteDirective": {
        "checkPoint": "条件编译代码块应在同一文件中",
        "level": "warning",
        "comment": "#if、#ifdef 与对应的 #else、#elif、#endif 应在同一文件中，否则会增加代码的维护成本。",
        "tag": "precompile",
        "reference": "MISRA C 2004 19.17,MISRA C 2012 20.14,MISRA C++ 2008 16-1-2"
        },
    "ID_accessSpecifierDisorder": {
        "checkPoint": "类成员应按 public、protected、private 的顺序声明",
        "level": "suggestion",
        "comment": "类成员统一按 public、protected、private 的顺序声明，有利于提高可读性。",
        "tag": "type"
        },
    "ID_returnNonConstData": {
        "checkPoint": "常量成员函数不应返回数据成员的非常量指针或引用",
        "level": "warning",
        "comment": "如果常量成员函数返回数据成员的非常量指针或引用，既打破了常量限定，又违反了封装理念，属于不良实现方式。",
        "tag": "type",
        "related": "ID_nonPrivateData,ID_qualifierCastedAway",
        "reference": "MISRA C++ 2008 9-3-1"
        }
}
